/**
 * ANVISA Compliance API
 * Comprehensive API for Brazilian Health Regulatory Agency (ANVISA) compliance
 * Handles product registration, adverse events, professional compliance, and regulatory reporting
 */

import { createClient } from '@neonpro/db';
import { z } from 'zod';

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

export type ANVISAProductCategory =
  | 'medical_device_class_i'
  | 'medical_device_class_ii'
  | 'medical_device_class_iii'
  | 'cosmetic_product'
  | 'pharmaceutical'
  | 'dermatological'
  | 'injectables'
  | 'implants'
  | 'surgical_instruments'
  | 'diagnostic_equipment';

export type ANVISARiskClass = 'low_risk' | 'moderate_risk' | 'high_risk' | 'critical_risk';

export type ANVISARegulatoryStatus =
  | 'active'
  | 'pending_renewal'
  | 'expired'
  | 'suspended'
  | 'revoked'
  | 'under_review';

export type ANVISAProcedureCategory =
  | 'aesthetic_minimally_invasive'
  | 'aesthetic_surgical'
  | 'cosmetic_treatment'
  | 'dermatological_treatment'
  | 'injectable_treatment'
  | 'laser_treatment'
  | 'radiofrequency_treatment'
  | 'surgical_procedure';

export type ANVISARiskLevel = 'minimal' | 'low' | 'moderate' | 'high' | 'critical';

export type ANVISAProfessionalLevel =
  | 'technician'
  | 'nurse'
  | 'specialist_nurse'
  | 'general_physician'
  | 'specialist_physician'
  | 'certified_specialist';

export type ANVISAEventType =
  | 'adverse_reaction'
  | 'device_malfunction'
  | 'product_quality_issue'
  | 'procedure_complication'
  | 'infection'
  | 'allergic_reaction'
  | 'unexpected_outcome';

export type ANVISASeverityLevel = 'mild' | 'moderate' | 'severe' | 'critical' | 'fatal';

export type ANVISAEventCategory =
  | 'product_related'
  | 'procedure_related'
  | 'professional_error'
  | 'system_failure'
  | 'patient_factor'
  | 'environmental_factor';

export type ANVISAEventOutcome =
  | 'recovered_completely'
  | 'recovered_with_sequelae'
  | 'ongoing_treatment'
  | 'hospitalization_required'
  | 'permanent_disability'
  | 'death';

export type ANVISAEventStatus =
  | 'reported'
  | 'under_investigation'
  | 'investigation_completed'
  | 'anvisa_notified'
  | 'closed'
  | 'follow_up_required';

export type ANVISAProduct = {
  id: string;
  clinic_id: string;
  anvisa_registration_number: string;
  product_name: string;
  manufacturer_name: string;
  manufacturer_country: string;
  supplier_name?: string;
  supplier_cnpj?: string;
  product_category: ANVISAProductCategory;
  risk_classification: ANVISARiskClass;
  is_medical_device: boolean;
  is_cosmetic_product: boolean;
  is_pharmaceutical: boolean;
  registration_date: string;
  registration_expiry_date?: string;
  last_renewal_date?: string;
  regulatory_status: ANVISARegulatoryStatus;
  composition?: string;
  concentration?: string;
  presentation_form?: string;
  packaging_size?: string;
  volume_weight?: string;
  technical_report_url?: string;
  safety_data_sheet_url?: string;
  certificate_of_analysis_url?: string;
  anvisa_approval_document_url?: string;
  current_stock_quantity: number;
  minimum_stock_level: number;
  maximum_stock_level: number;
  unit_cost?: number;
  last_inventory_check?: string;
  contraindications?: string;
  usage_warnings?: string;
  storage_requirements?: string;
  disposal_instructions?: string;
  professional_use_only: boolean;
  last_anvisa_inspection_date?: string;
  last_compliance_check?: string;
  compliance_notes?: string;
  created_at: string;
  updated_at: string;
  created_by?: string;
  updated_by?: string;
};

export type ANVISAProcedure = {
  id: string;
  clinic_id: string;
  procedure_code: string;
  procedure_name: string;
  procedure_category: ANVISAProcedureCategory;
  risk_level: ANVISARiskLevel;
  requires_medical_supervision: boolean;
  requires_specialist_certification: boolean;
  minimum_professional_qualification: ANVISAProfessionalLevel;
  required_certifications: string[];
  requires_informed_consent: boolean;
  requires_pre_procedure_evaluation: boolean;
  requires_post_procedure_monitoring: boolean;
  monitoring_period_days: number;
  contraindications?: string;
  safety_warnings?: string;
  emergency_protocols?: string;
  required_equipment: string[];
  required_medications: string[];
  anvisa_classification_code?: string;
  last_classification_update?: string;
  regulatory_notes?: string;
  success_rate_threshold: number;
  complication_rate_threshold: number;
  patient_satisfaction_threshold: number;
  is_active: boolean;
  created_at: string;
  updated_at: string;
  created_by?: string;
  updated_by?: string;
};

export type ANVISAAdverseEvent = {
  id: string;
  clinic_id: string;
  event_id: string;
  anvisa_notification_number?: string;
  patient_id?: string;
  appointment_id?: string;
  procedure_id?: string;
  professional_id?: string;
  product_id?: string;
  batch_number?: string;
  product_expiry_date?: string;
  event_type: ANVISAEventType;
  severity_level: ANVISASeverityLevel;
  event_category: ANVISAEventCategory;
  event_description: string;
  symptoms_observed?: string;
  onset_date_time: string;
  discovery_date_time: string;
  patient_age?: number;
  patient_gender?: string;
  medical_history_relevant?: string;
  concomitant_medications?: string;
  previous_adverse_reactions?: string;
  immediate_actions_taken?: string;
  treatment_provided?: string;
  hospitalization_required: boolean;
  hospitalization_duration_days?: number;
  event_outcome?: ANVISAEventOutcome;
  investigation_conducted: boolean;
  investigation_findings?: string;
  root_cause_analysis?: string;
  corrective_actions_taken?: string;
  preventive_measures_implemented?: string;
  anvisa_notification_required: boolean;
  anvisa_notification_sent: boolean;
  notification_date?: string;
  notification_response?: string;
  regulatory_follow_up_required: boolean;
  follow_up_required: boolean;
  follow_up_schedule?: string;
  resolution_date?: string;
  final_outcome?: string;
  investigated_by?: string;
  reviewed_by?: string;
  approved_by?: string;
  status: ANVISAEventStatus;
  created_at: string;
  updated_at: string;
  created_by?: string;
  updated_by?: string;
};

export type ANVISAProfessional = {
  id: string;
  clinic_id: string;
  user_id: string;
  professional_registration_number: string;
  cfm_registration?: string;
  crm_state?: string;
  specialty_code?: string;
  medical_degree_institution?: string;
  medical_degree_year?: number;
  residency_specialty?: string;
  residency_institution?: string;
  aesthetic_medicine_certification: boolean;
  certification_institution?: string;
  certification_date?: string;
  certification_expiry_date?: string;
  authorized_procedures: string[];
  procedure_certifications: Record<string, any>;
  training_records: any[];
  continuing_education_hours: number;
  license_status: ANVISALicenseStatus;
  last_verification_date?: string;
  next_verification_due?: string;
  compliance_score: number;
  procedures_performed_count: number;
  adverse_events_count: number;
  patient_satisfaction_average: number;
  regulatory_notes?: string;
  compliance_alerts: string[];
  restrictions?: string;
  is_active: boolean;
  created_at: string;
  updated_at: string;
  created_by?: string;
  updated_by?: string;
};

export type ANVISALicenseStatus =
  | 'active'
  | 'pending_renewal'
  | 'expired'
  | 'suspended'
  | 'revoked'
  | 'under_review';

// ============================================================================
// VALIDATION SCHEMAS
// ============================================================================

export const ANVISAProductSchema = z.object({
  anvisa_registration_number: z.string().min(1, 'ANVISA registration number is required'),
  product_name: z.string().min(1, 'Product name is required'),
  manufacturer_name: z.string().min(1, 'Manufacturer name is required'),
  manufacturer_country: z.string().min(1, 'Manufacturer country is required'),
  supplier_name: z.string().optional(),
  supplier_cnpj: z.string().optional(),
  product_category: z.enum([
    'medical_device_class_i',
    'medical_device_class_ii',
    'medical_device_class_iii',
    'cosmetic_product',
    'pharmaceutical',
    'dermatological',
    'injectables',
    'implants',
    'surgical_instruments',
    'diagnostic_equipment',
  ]),
  risk_classification: z.enum(['low_risk', 'moderate_risk', 'high_risk', 'critical_risk']),
  is_medical_device: z.boolean().default(false),
  is_cosmetic_product: z.boolean().default(false),
  is_pharmaceutical: z.boolean().default(false),
  registration_date: z.string(),
  registration_expiry_date: z.string().optional(),
  composition: z.string().optional(),
  concentration: z.string().optional(),
  current_stock_quantity: z.number().min(0, 'Stock quantity must be non-negative'),
  minimum_stock_level: z.number().min(0, 'Minimum stock level must be non-negative'),
  maximum_stock_level: z.number().min(0, 'Maximum stock level must be non-negative'),
  unit_cost: z.number().min(0, 'Unit cost must be non-negative').optional(),
  contraindications: z.string().optional(),
  usage_warnings: z.string().optional(),
  storage_requirements: z.string().optional(),
  disposal_instructions: z.string().optional(),
  professional_use_only: z.boolean().default(true),
  compliance_notes: z.string().optional(),
});

export const ANVISAAdverseEventSchema = z.object({
  patient_id: z.string().optional(),
  appointment_id: z.string().optional(),
  procedure_id: z.string().optional(),
  professional_id: z.string().optional(),
  product_id: z.string().optional(),
  batch_number: z.string().optional(),
  event_type: z.enum([
    'adverse_reaction',
    'device_malfunction',
    'product_quality_issue',
    'procedure_complication',
    'infection',
    'allergic_reaction',
    'unexpected_outcome',
  ]),
  severity_level: z.enum(['mild', 'moderate', 'severe', 'critical', 'fatal']),
  event_category: z.enum([
    'product_related',
    'procedure_related',
    'professional_error',
    'system_failure',
    'patient_factor',
    'environmental_factor',
  ]),
  event_description: z.string().min(10, 'Event description must be at least 10 characters'),
  symptoms_observed: z.string().optional(),
  onset_date_time: z.string(),
  patient_age: z.number().min(0).max(150).optional(),
  patient_gender: z.string().optional(),
  medical_history_relevant: z.string().optional(),
  immediate_actions_taken: z.string().optional(),
  treatment_provided: z.string().optional(),
  hospitalization_required: z.boolean().default(false),
  hospitalization_duration_days: z.number().min(0).optional(),
});

// ============================================================================
// API CLASS
// ============================================================================

export class ANVISAComplianceAPI {
  private readonly supabase = createClient();

  // ========================================================================
  // PRODUCT MANAGEMENT
  // ========================================================================

  async getProducts(clinicId: string): Promise<ANVISAProduct[]> {
    try {
      const { data, error } = await this.supabase
        .from('anvisa_products')
        .select('*')
        .eq('clinic_id', clinicId)
        .order('created_at', { ascending: false });

      if (error) {
        throw error;
      }
      return data || [];
    } catch (_error) {
      throw new Error('Failed to fetch products');
    }
  }

  async getProduct(productId: string): Promise<ANVISAProduct | null> {
    try {
      const { data, error } = await this.supabase
        .from('anvisa_products')
        .select('*')
        .eq('id', productId)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          return null;
        }
        throw error;
      }
      return data;
    } catch (_error) {
      throw new Error('Failed to fetch product');
    }
  }

  async createProduct(
    clinicId: string,
    productData: z.infer<typeof ANVISAProductSchema>
  ): Promise<ANVISAProduct> {
    try {
      const validatedData = ANVISAProductSchema.parse(productData);

      const { data, error } = await this.supabase
        .from('anvisa_products')
        .insert({
          clinic_id: clinicId,
          ...validatedData,
          regulatory_status: 'active' as ANVISARegulatoryStatus,
        })
        .select()
        .single();

      if (error) {
        throw error;
      }
      return data;
    } catch (_error) {
      throw new Error('Failed to create product');
    }
  }

  async updateProduct(
    productId: string,
    updates: Partial<z.infer<typeof ANVISAProductSchema>>
  ): Promise<ANVISAProduct> {
    try {
      const { data, error } = await this.supabase
        .from('anvisa_products')
        .update(updates)
        .eq('id', productId)
        .select()
        .single();

      if (error) {
        throw error;
      }
      return data;
    } catch (_error) {
      throw new Error('Failed to update product');
    }
  }

  async deleteProduct(productId: string): Promise<boolean> {
    try {
      const { error } = await this.supabase.from('anvisa_products').delete().eq('id', productId);

      if (error) {
        throw error;
      }
      return true;
    } catch (_error) {
      throw new Error('Failed to delete product');
    }
  }

  async getProductsNearingExpiry(clinicId: string, daysAhead = 30): Promise<any[]> {
    try {
      const { data, error } = await this.supabase.rpc('get_products_nearing_expiry', {
        p_clinic_id: clinicId,
        p_days_ahead: daysAhead,
      });

      if (error) {
        throw error;
      }
      return data || [];
    } catch (_error) {
      throw new Error('Failed to fetch products nearing expiry');
    }
  }

  async updateProductStock(
    productId: string,
    quantityChange: number,
    operationType = 'usage'
  ): Promise<boolean> {
    try {
      const { data, error } = await this.supabase.rpc('update_product_stock', {
        p_product_id: productId,
        p_quantity_change: quantityChange,
        p_operation_type: operationType,
      });

      if (error) {
        throw error;
      }
      return data;
    } catch (_error) {
      throw new Error('Failed to update product stock');
    }
  }

  // ========================================================================
  // PROCEDURE MANAGEMENT
  // ========================================================================

  async getProcedures(clinicId: string): Promise<ANVISAProcedure[]> {
    try {
      const { data, error } = await this.supabase
        .from('anvisa_procedures')
        .select('*')
        .eq('clinic_id', clinicId)
        .eq('is_active', true)
        .order('procedure_name', { ascending: true });

      if (error) {
        throw error;
      }
      return data || [];
    } catch (_error) {
      throw new Error('Failed to fetch procedures');
    }
  }

  async getProcedure(procedureId: string): Promise<ANVISAProcedure | null> {
    try {
      const { data, error } = await this.supabase
        .from('anvisa_procedures')
        .select('*')
        .eq('id', procedureId)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          return null;
        }
        throw error;
      }
      return data;
    } catch (_error) {
      throw new Error('Failed to fetch procedure');
    }
  }

  async verifyProfessionalAuthorization(
    professionalId: string,
    procedureCode: string
  ): Promise<boolean> {
    try {
      const { data, error } = await this.supabase.rpc('verify_professional_authorization', {
        p_professional_id: professionalId,
        p_procedure_code: procedureCode,
      });

      if (error) {
        throw error;
      }
      return data;
    } catch (_error) {
      throw new Error('Failed to verify professional authorization');
    }
  }

  // ========================================================================
  // ADVERSE EVENT MANAGEMENT
  // ========================================================================

  async getAdverseEvents(clinicId: string): Promise<ANVISAAdverseEvent[]> {
    try {
      const { data, error } = await this.supabase
        .from('anvisa_adverse_events')
        .select(
          `
          *,
          patient:patients(id, full_name),
          procedure:anvisa_procedures(procedure_name),
          product:anvisa_products(product_name),
          professional:users(id, full_name)
        `
        )
        .eq('clinic_id', clinicId)
        .order('onset_date_time', { ascending: false });

      if (error) {
        throw error;
      }
      return data || [];
    } catch (_error) {
      throw new Error('Failed to fetch adverse events');
    }
  }

  async getAdverseEvent(eventId: string): Promise<ANVISAAdverseEvent | null> {
    try {
      const { data, error } = await this.supabase
        .from('anvisa_adverse_events')
        .select(
          `
          *,
          patient:patients(id, full_name, date_of_birth, gender),
          procedure:anvisa_procedures(procedure_name, procedure_category),
          product:anvisa_products(product_name, manufacturer_name),
          professional:users(id, full_name)
        `
        )
        .eq('id', eventId)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          return null;
        }
        throw error;
      }
      return data;
    } catch (_error) {
      throw new Error('Failed to fetch adverse event');
    }
  }

  async createAdverseEvent(
    clinicId: string,
    eventData: z.infer<typeof ANVISAAdverseEventSchema>
  ): Promise<ANVISAAdverseEvent> {
    try {
      const validatedData = ANVISAAdverseEventSchema.parse(eventData);

      const { data, error } = await this.supabase.rpc('create_adverse_event', {
        p_clinic_id: clinicId,
        p_patient_id: validatedData.patient_id,
        p_procedure_id: validatedData.procedure_id,
        p_product_id: validatedData.product_id,
        p_event_description: validatedData.event_description,
        p_severity_level: validatedData.severity_level,
        p_onset_date_time: validatedData.onset_date_time,
      });

      if (error) {
        throw error;
      }

      // Return the created event
      return await this.getAdverseEvent(data);
    } catch (_error) {
      throw new Error('Failed to create adverse event');
    }
  }

  async updateAdverseEventStatus(
    eventId: string,
    status: ANVISAEventStatus,
    notes?: string
  ): Promise<boolean> {
    try {
      const { data, error } = await this.supabase.rpc('update_adverse_event_status', {
        p_event_id: eventId,
        p_new_status: status,
        p_notes: notes,
      });

      if (error) {
        throw error;
      }
      return data;
    } catch (_error) {
      throw new Error('Failed to update adverse event status');
    }
  }

  async getPendingANVISANotifications(clinicId: string): Promise<any[]> {
    try {
      const { data, error } = await this.supabase.rpc('get_pending_anvisa_notifications', {
        p_clinic_id: clinicId,
      });

      if (error) {
        throw error;
      }
      return data || [];
    } catch (_error) {
      throw new Error('Failed to fetch pending notifications');
    }
  }

  // ========================================================================
  // PROFESSIONAL MANAGEMENT
  // ========================================================================

  async getProfessionals(clinicId: string): Promise<ANVISAProfessional[]> {
    try {
      const { data, error } = await this.supabase
        .from('anvisa_professionals')
        .select(
          `
          *,
          user:users(id, full_name, email)
        `
        )
        .eq('clinic_id', clinicId)
        .eq('is_active', true)
        .order('created_at', { ascending: false });

      if (error) {
        throw error;
      }
      return data || [];
    } catch (_error) {
      throw new Error('Failed to fetch professionals');
    }
  }

  async updateProfessionalComplianceScore(professionalId: string): Promise<number> {
    try {
      const { data, error } = await this.supabase.rpc('update_professional_compliance_score', {
        p_professional_id: professionalId,
      });

      if (error) {
        throw error;
      }
      return data;
    } catch (_error) {
      throw new Error('Failed to update compliance score');
    }
  }

  // ========================================================================
  // COMPLIANCE MONITORING
  // ========================================================================

  async calculateClinicComplianceScore(clinicId: string): Promise<any> {
    try {
      const { data, error } = await this.supabase.rpc('calculate_clinic_compliance_score', {
        p_clinic_id: clinicId,
      });

      if (error) {
        throw error;
      }
      return data;
    } catch (_error) {
      throw new Error('Failed to calculate compliance score');
    }
  }

  async generateComplianceReport(
    clinicId: string,
    startDate?: string,
    endDate?: string
  ): Promise<any> {
    try {
      const { data, error } = await this.supabase.rpc('generate_compliance_report', {
        p_clinic_id: clinicId,
        p_start_date: startDate,
        p_end_date: endDate,
      });

      if (error) {
        throw error;
      }
      return data;
    } catch (_error) {
      throw new Error('Failed to generate compliance report');
    }
  }

  // ========================================================================
  // BATCH MANAGEMENT
  // ========================================================================

  async getBatchesNearingExpiry(clinicId: string, daysAhead = 30): Promise<any[]> {
    try {
      const { data, error } = await this.supabase.rpc('get_batches_nearing_expiry', {
        p_clinic_id: clinicId,
        p_days_ahead: daysAhead,
      });

      if (error) {
        throw error;
      }
      return data || [];
    } catch (_error) {
      throw new Error('Failed to fetch batches nearing expiry');
    }
  }

  async useProductFromBatch(
    batchId: string,
    quantity: number,
    procedureId?: string
  ): Promise<boolean> {
    try {
      const { data, error } = await this.supabase.rpc('use_product_from_batch', {
        p_batch_id: batchId,
        p_quantity: quantity,
        p_procedure_id: procedureId,
      });

      if (error) {
        throw error;
      }
      return data;
    } catch (_error) {
      throw new Error('Failed to use product from batch');
    }
  }

  // ========================================================================
  // ALERTS AND NOTIFICATIONS
  // ========================================================================

  async getAlerts(clinicId: string): Promise<any[]> {
    try {
      const { data, error } = await this.supabase
        .from('anvisa_alerts')
        .select('*')
        .eq('clinic_id', clinicId)
        .eq('is_resolved', false)
        .order('created_at', { ascending: false });

      if (error) {
        throw error;
      }
      return data || [];
    } catch (_error) {
      throw new Error('Failed to fetch alerts');
    }
  }

  async markAlertAsResolved(alertId: string): Promise<boolean> {
    try {
      const { error } = await this.supabase
        .from('anvisa_alerts')
        .update({
          is_resolved: true,
          resolved_at: new Date().toISOString(),
        })
        .eq('id', alertId);

      if (error) {
        throw error;
      }
      return true;
    } catch (_error) {
      throw new Error('Failed to mark alert as resolved');
    }
  }

  async sendPendingAlerts(): Promise<number> {
    try {
      const { data, error } = await this.supabase.rpc('send_pending_alerts');

      if (error) {
        throw error;
      }
      return data;
    } catch (_error) {
      throw new Error('Failed to send pending alerts');
    }
  }
}

export const anvisaAPI = new ANVISAComplianceAPI();
