// LGPD Compliance API Routes
// NeonPro Healthcare Clinic Management System
// Created: 2024-01-15

import { createClient } from '@neonpro/db';
import { type NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';

// ============================================================================
// VALIDATION SCHEMAS
// ============================================================================

const ConsentRequestSchema = z.object({
  purposeName: z.string().min(1, 'Purpose name is required'),
  granted: z.boolean(),
  ipAddress: z.string().optional(),
  userAgent: z.string().optional(),
});

const DataSubjectRequestSchema = z.object({
  requestType: z.enum([
    'access',
    'rectification',
    'erasure',
    'restriction',
    'portability',
    'objection',
  ]),
  details: z.record(z.any()).optional(),
  reason: z.string().optional(),
});

const DataRectificationSchema = z.object({
  field: z.string().min(1, 'Field name is required'),
  oldValue: z.string(),
  newValue: z.string(),
  reason: z.string().min(1, 'Reason for rectification is required'),
});

// ============================================================================
// CONSENT MANAGEMENT ENDPOINTS
// ============================================================================

/**
 * POST /api/lgpd/consent/grant
 * Grant consent for a specific purpose
 */
export async function grantConsent(request: NextRequest) {
  try {
    const supabase = createClient();
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await request.json();
    const validation = ConsentRequestSchema.safeParse(body);

    if (!validation.success) {
      return NextResponse.json(
        {
          error: 'Validation failed',
          details: validation.error.errors,
        },
        { status: 400 }
      );
    }

    const { purposeName, granted, ipAddress, userAgent } = validation.data;

    // Get purpose ID
    const { data: purpose, error: purposeError } = await supabase
      .from('consent_purposes')
      .select('id, legal_basis, version')
      .eq('name', purposeName)
      .eq('active', true)
      .single();

    if (purposeError || !purpose) {
      return NextResponse.json({ error: 'Invalid consent purpose' }, { status: 400 });
    }

    // Record consent
    const { data: consent, error: consentError } = await supabase
      .from('user_consents')
      .upsert({
        user_id: user.id,
        purpose_id: purpose.id,
        granted,
        legal_basis: purpose.legal_basis,
        consent_version: purpose.version,
        ip_address: ipAddress || request.ip,
        user_agent: userAgent || request.headers.get('user-agent'),
        proof_hash: generateConsentProofHash(user.id, purpose.id, granted),
      })
      .select()
      .single();

    if (consentError) {
      return NextResponse.json({ error: 'Failed to record consent' }, { status: 500 });
    }

    // Log for audit
    await supabase.from('lgpd_audit_logs').insert({
      user_id: user.id,
      action: 'consent_granted',
      resource_type: 'consent',
      resource_id: purpose.id,
      new_values: {
        purpose: purposeName,
        granted,
        timestamp: new Date().toISOString(),
      },
    });

    return NextResponse.json({
      success: true,
      consent,
      message: `Consent ${granted ? 'granted' : 'denied'} for ${purposeName}`,
    });
  } catch (_error) {
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

/**
 * POST /api/lgpd/consent/withdraw
 * Withdraw consent for a specific purpose
 */
export async function withdrawConsent(request: NextRequest) {
  try {
    const supabase = createClient();
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { purposeName, reason } = await request.json();

    if (!purposeName) {
      return NextResponse.json({ error: 'Purpose name is required' }, { status: 400 });
    }

    // Call database function to withdraw consent
    const { data, error } = await supabase.rpc('withdraw_consent', {
      p_user_id: user.id,
      p_purpose_name: purposeName,
      p_reason: reason || 'User withdrawal',
    });

    if (error) {
      return NextResponse.json({ error: 'Failed to withdraw consent' }, { status: 500 });
    }

    if (!data) {
      return NextResponse.json({ error: 'No active consent found to withdraw' }, { status: 404 });
    }

    return NextResponse.json({
      success: true,
      message: `Consent withdrawn for ${purposeName}`,
    });
  } catch (_error) {
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

/**
 * GET /api/lgpd/consent/status
 * Get current consent status for user
 */
export async function getConsentStatus(_request: NextRequest) {
  try {
    const supabase = createClient();
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Get user's current consents with purpose details
    const { data: consents, error } = await supabase
      .from('user_consents')
      .select(
        `
        *,
        consent_purposes (
          name,
          description,
          category,
          required,
          processing_purpose
        )
      `
      )
      .eq('user_id', user.id)
      .is('withdrawn_at', null)
      .order('granted_at', { ascending: false });

    if (error) {
      return NextResponse.json({ error: 'Failed to get consent status' }, { status: 500 });
    }

    // Get all available purposes for comparison
    const { data: allPurposes, error: purposesError } = await supabase
      .from('consent_purposes')
      .select('name, description, category, required')
      .eq('active', true);

    if (purposesError) {
      return NextResponse.json({ error: 'Failed to get consent purposes' }, { status: 500 });
    }

    // Build consent status response
    const consentStatus = allPurposes.map((purpose) => {
      const userConsent = consents?.find((c) => c.consent_purposes.name === purpose.name);
      return {
        purpose: purpose.name,
        description: purpose.description,
        category: purpose.category,
        required: purpose.required,
        granted: userConsent?.granted,
        grantedAt: userConsent?.granted_at || null,
        version: userConsent?.consent_version || null,
      };
    });

    return NextResponse.json({ consents: consentStatus });
  } catch (_error) {
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

// ============================================================================
// DATA SUBJECT RIGHTS ENDPOINTS
// ============================================================================

/**
 * POST /api/lgpd/data-rights/request
 * Create a data subject rights request
 */
export async function createDataSubjectRequest(request: NextRequest) {
  try {
    const supabase = createClient();
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await request.json();
    const validation = DataSubjectRequestSchema.safeParse(body);

    if (!validation.success) {
      return NextResponse.json(
        {
          error: 'Validation failed',
          details: validation.error.errors,
        },
        { status: 400 }
      );
    }

    const { requestType, details, reason } = validation.data;

    // Create request using database function
    const { data: requestId, error } = await supabase.rpc('create_data_subject_request', {
      p_user_id: user.id,
      p_request_type: requestType,
      p_details: details ? JSON.stringify(details) : null,
    });

    if (error) {
      return NextResponse.json({ error: 'Failed to create request' }, { status: 500 });
    }

    // Get the created request details
    const { data: requestDetails, error: detailsError } = await supabase
      .from('data_subject_requests')
      .select('*')
      .eq('id', requestId)
      .single();

    if (detailsError) {
      return NextResponse.json(
        { error: 'Request created but failed to get details' },
        { status: 500 }
      );
    }

    return NextResponse.json({
      success: true,
      request: requestDetails,
      message: `${requestType} request created successfully. You will receive a response within 15 days.`,
    });
  } catch (_error) {
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

/**
 * GET /api/lgpd/data-rights/export/[token]
 * Download data export package
 */
export async function downloadDataExport(
  _request: NextRequest,
  { params }: { params: { token: string } }
) {
  try {
    const supabase = createClient();
    const { token } = params;

    // Validate export token
    const { data: exportPackage, error } = await supabase
      .from('data_export_packages')
      .select(
        `
        *,
        data_subject_requests (
          user_id,
          status
        )
      `
      )
      .eq('verification_token', token)
      .gt('expiry_date', new Date().toISOString())
      .single();

    if (error || !exportPackage) {
      return NextResponse.json({ error: 'Invalid or expired export token' }, { status: 404 });
    }

    // Check if request is completed
    if (exportPackage.data_subject_requests.status !== 'completed') {
      return NextResponse.json({ error: 'Export not ready yet' }, { status: 400 });
    }

    // Increment download count
    await supabase
      .from('data_export_packages')
      .update({
        download_count: exportPackage.download_count + 1,
        last_downloaded_at: new Date().toISOString(),
      })
      .eq('id', exportPackage.id);

    // Check download limits
    if (exportPackage.download_count >= exportPackage.max_downloads) {
      return NextResponse.json({ error: 'Maximum download limit reached' }, { status: 403 });
    }

    // Generate user data export
    const { data: exportData, error: exportError } = await supabase.rpc(
      'generate_user_data_export',
      {
        p_user_id: exportPackage.data_subject_requests.user_id,
      }
    );

    if (exportError) {
      return NextResponse.json({ error: 'Failed to generate export' }, { status: 500 });
    }

    // Return export data
    return NextResponse.json(exportData, {
      headers: {
        'Content-Type': 'application/json',
        'Content-Disposition': `attachment; filename="personal_data_export_${Date.now()}.json"`,
      },
    });
  } catch (_error) {
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

/**
 * POST /api/lgpd/data-rights/rectification
 * Request data rectification
 */
export async function requestDataRectification(request: NextRequest) {
  try {
    const supabase = createClient();
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await request.json();
    const validation = DataRectificationSchema.safeParse(body);

    if (!validation.success) {
      return NextResponse.json(
        {
          error: 'Validation failed',
          details: validation.error.errors,
        },
        { status: 400 }
      );
    }

    const { field, oldValue, newValue, reason } = validation.data;

    // Create rectification request
    const { data: requestId, error } = await supabase.rpc('create_data_subject_request', {
      p_user_id: user.id,
      p_request_type: 'rectification',
      p_details: JSON.stringify({
        field,
        oldValue,
        newValue,
        reason,
      }),
    });

    if (error) {
      return NextResponse.json(
        { error: 'Failed to create rectification request' },
        { status: 500 }
      );
    }

    return NextResponse.json({
      success: true,
      requestId,
      message:
        'Data rectification request created. It will be reviewed and processed within 15 days.',
    });
  } catch (_error) {
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

// ============================================================================
// COMPLIANCE MONITORING ENDPOINTS
// ============================================================================

/**
 * GET /api/lgpd/compliance/status
 * Get compliance status for user
 */
export async function getComplianceStatus(_request: NextRequest) {
  try {
    const supabase = createClient();
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Get user's data subject requests
    const { data: requests, error: requestsError } = await supabase
      .from('data_subject_requests')
      .select('*')
      .eq('user_id', user.id)
      .order('requested_at', { ascending: false });

    if (requestsError) {
      return NextResponse.json({ error: 'Failed to get requests' }, { status: 500 });
    }

    // Check if user has all required consents
    const { data: hasRequiredConsents, error: consentError } = await supabase
      .from('user_consents')
      .select(
        `
        consent_purposes!inner(required)
      `
      )
      .eq('user_id', user.id)
      .eq('granted', true)
      .is('withdrawn_at', null)
      .eq('consent_purposes.required', true);

    if (consentError) {
      return NextResponse.json({ error: 'Failed to check consent status' }, { status: 500 });
    }

    // Get count of required purposes
    const { count: requiredPurposesCount, error: countError } = await supabase
      .from('consent_purposes')
      .select('*', { count: 'exact', head: true })
      .eq('required', true)
      .eq('active', true);

    if (countError) {
    }

    const complianceStatus = {
      userId: user.id,
      consentCompliance: {
        hasAllRequiredConsents: (hasRequiredConsents?.length || 0) === (requiredPurposesCount || 0),
        requiredConsentsCount: requiredPurposesCount || 0,
        grantedRequiredConsentsCount: hasRequiredConsents?.length || 0,
      },
      dataRequests: {
        totalRequests: requests?.length || 0,
        pendingRequests: requests?.filter((r) => r.status === 'pending').length || 0,
        completedRequests: requests?.filter((r) => r.status === 'completed').length || 0,
        recentRequests: requests?.slice(0, 5) || [],
      },
      lastUpdated: new Date().toISOString(),
    };

    return NextResponse.json(complianceStatus);
  } catch (_error) {
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

function generateConsentProofHash(userId: string, purposeId: string, granted: boolean): string {
  const content = `${userId}:${purposeId}:${granted}:${Date.now()}`;
  return Buffer.from(content).toString('base64');
}

// Export helpers for API routes
export {
  grantConsent,
  withdrawConsent,
  getConsentStatus,
  createDataSubjectRequest,
  downloadDataExport,
  requestDataRectification,
  getComplianceStatus,
};
