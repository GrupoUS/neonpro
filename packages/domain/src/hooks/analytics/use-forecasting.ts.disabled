/**
 * Advanced Forecasting React Hook for NeonPro
 *
 * Custom hook providing comprehensive forecasting capabilities including:
 * - ML-inspired time series forecasting
 * - Scenario analysis and sensitivity testing
 * - Statistical model evaluation and confidence intervals
 * - Real-time prediction updates with data validation
 * - Export capabilities for forecasting reports
 *
 * Integrates with ForecastingEngine service and provides UI-ready prediction data.
 */

import { useMutation, useQuery, useQueryClient } from '../placeholders/react-query';
import { useCallback, useEffect, useMemo, useState } from 'react';
import {
  createForecastingEngine,
  type ForecastingConfig,
  type ForecastResult,
  forecastingUtils,
  type ModelEvaluation,
  type ScenarioConfig,
} // Missing module - placeholder needed
import { createClient } // Missing module - placeholder needed

// Types for hook configuration and state
export type ForecastingHookConfig = {
  metric: 'revenue' | 'subscriptions' | 'churn' | 'trials';
  timeHorizon: 30 | 90 | 180 | 365; // days
  model: 'linear' | 'exponential' | 'seasonal' | 'auto';
  granularity: 'daily' | 'weekly' | 'monthly';
  confidenceLevel: 90 | 95 | 99;
  includeSeasonality: boolean;
  includeTrends: boolean;
  autoRefresh?: boolean;
  refreshInterval?: number;
};

export type ForecastingState = {
  forecast: ForecastResult | null;
  scenarios: { [key: string]: ForecastResult };
  evaluation: ModelEvaluation | null;
  predictions: any[];
  chartData: any[];
  confidence: {
    upper: number[];
    lower: number[];
    mean: number[];
  };
  accuracy: {
    mape: number;
    rmse: number;
    r2: number;
  };
  isLoading: boolean;
  error: string | null;
  lastUpdated: Date | null;
};

export type ForecastingActions = {
  generateForecast: (config: ForecastingConfig) => Promise<void>;
  runScenario: (name: string, config: ScenarioConfig) => Promise<void>;
  updateModel: (modelType: string) => Promise<void>;
  refreshData: () => Promise<void>;
  exportForecast: (format: 'csv' | 'excel' | 'pdf') => Promise<void>;
  updateConfig: (newConfig: Partial<ForecastingHookConfig>) => void;
};

/**
 * Main forecasting hook
 */
export function useForecasting(
  initialConfig: ForecastingHookConfig
): ForecastingState & ForecastingActions {
  const queryClient = useQueryClient();
  const _supabase = createClient();
  const [config, setConfig] = useState<ForecastingHookConfig>(initialConfig);
  const [scenarios, setScenarios] = useState<{ [key: string]: ForecastResult }>({});
  const [error, setError] = useState<string | null>(null);

  // Initialize forecasting engine
  const forecastingEngine = useMemo(() => createForecastingEngine(), []);

  // Query key for caching
  const queryKey = useMemo(
    () => [
      'forecasting',
      config.metric,
      config.timeHorizon,
      config.model,
      config.granularity,
      config.confidenceLevel,
    ],
    [config]
  );

  // Main forecasting query
  const {
    data: forecastData,
    isLoading,
    refetch: refreshData,
  } = useQuery({
    queryKey,
    queryFn: async () => {
      const forecastConfig: ForecastingConfig = {
        metric: config.metric,
        timeHorizon: config.timeHorizon,
        model: config.model === 'auto' ? 'seasonal' : config.model,
        granularity: config.granularity,
        confidenceLevel: config.confidenceLevel,
        includeSeasonality: config.includeSeasonality,
        includeTrends: config.includeTrends,
        startDate: new Date(Date.now() - 365 * 24 * 60 * 60 * 1000).toISOString(), // Last year
        endDate: new Date().toISOString(),
      };

      // Generate main forecast
      const forecast = await forecastingEngine.generateForecast(forecastConfig);

      if (!forecast?.predictions || forecast.predictions.length === 0) {
        throw new Error('No forecast data generated');
      }

      // Evaluate model performance
      const evaluation = await forecastingEngine.evaluateModel(forecast, forecastConfig);

      // Generate sensitivity analysis
      const sensitivityAnalysis = await forecastingEngine.performSensitivityAnalysis(
        forecastConfig,
        ['growth_rate', 'seasonal_factor', 'trend_strength']
      );

      // Format data for visualization
      const chartData = forecastingUtils.formatForChart(forecast, config.granularity);
      const confidenceIntervals = forecastingUtils.calculateConfidenceIntervals(
        forecast.predictions,
        config.confidenceLevel
      );

      return {
        forecast,
        evaluation,
        sensitivityAnalysis,
        chartData,
        confidenceIntervals,
        predictions: forecast.predictions,
        accuracy: {
          mape: evaluation.metrics.mape,
          rmse: evaluation.metrics.rmse,
          r2: evaluation.metrics.r2,
        },
      };
    },
    staleTime: 10 * 60 * 1000, // 10 minutes
    cacheTime: 60 * 60 * 1000, // 1 hour
    retry: 2,
    refetchOnWindowFocus: false,
    enabled: Boolean(config.metric) && config.timeHorizon > 0,
  });

  // Auto-refresh effect
  useEffect(() => {
    if (!(config.autoRefresh && config.refreshInterval)) {
      return;
    }

    const interval = setInterval(() => {
      refreshData();
    }, config.refreshInterval * 1000);

    return () => clearInterval(interval);
  }, [config.autoRefresh, config.refreshInterval, refreshData]);

  // Generate forecast mutation
  const generateForecastMutation = useMutation({
    mutationFn: async (newConfig: ForecastingConfig) => {
      const forecast = await forecastingEngine.generateForecast(newConfig);
      const evaluation = await forecastingEngine.evaluateModel(forecast, newConfig);

      return { forecast, evaluation };
    },
    onSuccess: (data) => {
      queryClient.setQueryData(queryKey, data);
      setError(null);
    },
    onError: (err) => {
      setError(err instanceof Error ? err.message : 'Forecast generation failed');
    },
  });

  // Run scenario mutation
  const runScenarioMutation = useMutation({
    mutationFn: async ({
      name,
      scenarioConfig,
    }: {
      name: string;
      scenarioConfig: ScenarioConfig;
    }) => {
      if (!forecastData?.forecast) {
        throw new Error('Base forecast required for scenario analysis');
      }

      const scenarioResult = await forecastingEngine.runScenarioAnalysis(
        forecastData.forecast,
        scenarioConfig
      );

      return { name, result: scenarioResult };
    },
    onSuccess: ({ name, result }) => {
      setScenarios((prev) => ({ ...prev, [name]: result }));
      setError(null);
    },
    onError: (err) => {
      setError(err instanceof Error ? err.message : 'Scenario analysis failed');
    },
  });

  // Export forecast mutation
  const exportForecastMutation = useMutation({
    mutationFn: async (format: 'csv' | 'excel' | 'pdf') => {
      if (!forecastData) {
        throw new Error('No forecast data to export');
      }

      const response = await fetch('/api/analytics/export', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          type: 'forecasting',
          format,
          data: {
            forecast: forecastData.forecast,
            evaluation: forecastData.evaluation,
            scenarios,
            config,
          },
        }),
      });

      if (!response.ok) {
        throw new Error('Export failed');
      }

      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `forecast-${config.metric}-${new Date().toISOString().split('T')[0]}.${format}`;
      document.body.appendChild(a);
      a.click();
      window.URL.revokeObjectURL(url);
      document.body.removeChild(a);
    },
    onError: (err) => {
      setError(err instanceof Error ? err.message : 'Export failed');
    },
  });

  // Actions
  const generateForecast = useCallback(
    async (newConfig: ForecastingConfig) => {
      await generateForecastMutation.mutateAsync(newConfig);
    },
    [generateForecastMutation]
  );

  const runScenario = useCallback(
    async (name: string, scenarioConfig: ScenarioConfig) => {
      await runScenarioMutation.mutateAsync({ name, scenarioConfig });
    },
    [runScenarioMutation]
  );

  const updateModel = useCallback(
    async (modelType: string) => {
      const newConfig = { ...config, model: modelType as any };
      setConfig(newConfig);
      await refreshData();
    },
    [config, refreshData]
  );

  const exportForecast = useCallback(
    async (format: 'csv' | 'excel' | 'pdf') => {
      await exportForecastMutation.mutateAsync(format);
    },
    [exportForecastMutation]
  );

  const updateConfig = useCallback((newConfig: Partial<ForecastingHookConfig>) => {
    setConfig((prev) => ({ ...prev, ...newConfig }));
    setError(null);
  }, []);

  // Return hook interface
  return {
    // State
    forecast: forecastData?.forecast || null,
    scenarios,
    evaluation: forecastData?.evaluation || null,
    predictions: forecastData?.predictions || [],
    chartData: forecastData?.chartData || [],
    confidence: forecastData?.confidenceIntervals || {
      upper: [],
      lower: [],
      mean: [],
    },
    accuracy: forecastData?.accuracy || { mape: 0, rmse: 0, r2: 0 },
    isLoading: isLoading || generateForecastMutation.isPending || runScenarioMutation.isPending,
    error:
      error ||
      generateForecastMutation.error?.message ||
      runScenarioMutation.error?.message ||
      null,
    lastUpdated: forecastData ? new Date() : null,

    // Actions
    generateForecast,
    runScenario,
    updateModel,
    refreshData,
    exportForecast,
    updateConfig,
  };
}

/**
 * Hook for forecast comparison analysis
 */
export function useForecastComparison(forecasts: ForecastResult[]) {
  const _queryClient = useQueryClient();

  return useQuery({
    queryKey: ['forecast-comparison', forecasts.map((f) => f.config.metric)],
    queryFn: async () => {
      const response = await fetch('/api/analytics/advanced?type=forecasting', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'compare',
          forecasts,
          includeCorrelations: true,
        }),
      });

      if (!response.ok) {
        throw new Error('Forecast comparison failed');
      }
      return response.json();
    },
    enabled: forecasts.length > 1,
    staleTime: 15 * 60 * 1000, // 15 minutes
  });
}

/**
 * Hook for real-time forecast updates
 */
export function useRealTimeForecastUpdates(metric: string, enabled = true) {
  const [updates, setUpdates] = useState<any[]>([]);
  const supabase = createClient();

  useEffect(() => {
    if (!(enabled && metric)) {
      return;
    }

    // Subscribe to real-time data changes that might affect forecasts
    const subscription = supabase
      .channel(`forecast-updates-${metric}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: metric === 'revenue' ? 'subscription_revenue' : 'subscriptions',
        },
        (payload) => {
          // Add update to queue for forecast recalculation
          setUpdates((prev) => [
            ...prev,
            {
              timestamp: new Date(),
              type: payload.eventType,
              data: payload.new || payload.old,
              table: payload.table,
            },
          ]);
        }
      )
      .subscribe();

    return () => {
      subscription.unsubscribe();
    };
  }, [metric, enabled, supabase]);

  return updates;
}

/**
 * Hook for forecast accuracy tracking
 */
export function useForecastAccuracy(metric: string, timeWindow = 30) {
  return useQuery({
    queryKey: ['forecast-accuracy', metric, timeWindow],
    queryFn: async () => {
      const response = await fetch('/api/analytics/accuracy', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          metric,
          timeWindow,
          includeBreakdown: true,
        }),
      });

      if (!response.ok) {
        throw new Error('Failed to fetch accuracy data');
      }
      return response.json();
    },
    staleTime: 60 * 60 * 1000, // 1 hour
    enabled: Boolean(metric),
  });
}

/**
 * Utility hook for forecast data formatting
 */
export function useForecastFormatters() {
  return useMemo(
    () => ({
      formatPrediction: (value: number, metric: string): string => {
        if (metric === 'revenue') {
          return new Intl.NumberFormat('en-US', {
            style: 'currency',
            currency: 'USD',
          }).format(value);
        }
        if (metric === 'churn') {
          return `${Math.round(value * 100) / 100}%`;
        }
        return Math.round(value).toLocaleString();
      },

      formatAccuracy: (value: number): string => {
        return `${Math.round(value * 100) / 100}%`;
      },

      formatConfidenceInterval: (lower: number, upper: number, metric: string): string => {
        const formatValue = (v: number) => {
          if (metric === 'revenue') {
            return new Intl.NumberFormat('en-US', {
              style: 'currency',
              currency: 'USD',
              minimumFractionDigits: 0,
            }).format(v);
          }
          if (metric === 'churn') {
            return `${Math.round(v * 100) / 100}%`;
          }
          return Math.round(v).toLocaleString();
        };

        return `${formatValue(lower)} - ${formatValue(upper)}`;
      },

      getAccuracyColor: (accuracy: number): string => {
        if (accuracy >= 90) {
          return 'text-green-600';
        }
        if (accuracy >= 75) {
          return 'text-yellow-600';
        }
        return 'text-red-600';
      },

      getAccuracyBadgeVariant: (accuracy: number): 'default' | 'secondary' | 'destructive' => {
        if (accuracy >= 90) {
          return 'default';
        }
        if (accuracy >= 75) {
          return 'secondary';
        }
        return 'destructive';
      },

      formatTimeHorizon: (days: number): string => {
        if (days < 7) {
          return `${days} day${days > 1 ? 's' : ''}`;
        }
        if (days < 30) {
          return `${Math.round(days / 7)} week${Math.round(days / 7) > 1 ? 's' : ''}`;
        }
        if (days < 365) {
          return `${Math.round(days / 30)} month${Math.round(days / 30) > 1 ? 's' : ''}`;
        }
        return `${Math.round(days / 365)} year${Math.round(days / 365) > 1 ? 's' : ''}`;
      },
    }),
    []
  );
}
