// NeonPro - useNetworkStatus Hook
// VIBECODE V1.0 - Professional Excellence Standards
// Purpose: React hook for network connectivity detection with healthcare PWA patterns

'use client';

import { useCallback, useEffect, useState } from 'react';

type NetworkStatus = {
  isOnline: boolean;
  isOffline: boolean;
  downlink?: number;
  effectiveType?: string;
  saveData?: boolean;
};

type SyncQueueItem = {
  id: string;
  method: string;
  url: string;
  data?: any;
  timestamp: number;
  retryCount: number;
};

export function useNetworkStatus() {
  const [networkStatus, setNetworkStatus] = useState<NetworkStatus>({
    isOnline: true,
    isOffline: false,
  });

  const [syncQueue, setSyncQueue] = useState<SyncQueueItem[]>([]);
  const [isSyncing, setIsSyncing] = useState(false);

  // Update network status
  const updateNetworkStatus = useCallback(() => {
    const connection = (navigator as any).connection;
    const isOnline = navigator.onLine;

    setNetworkStatus({
      isOnline,
      isOffline: !isOnline,
      downlink: connection?.downlink,
      effectiveType: connection?.effectiveType,
      saveData: connection?.saveData,
    });
  }, []);

  // Load sync queue from localStorage
  const loadSyncQueue = useCallback(() => {
    try {
      const stored = localStorage.getItem('neonpro-sync-queue');
      if (stored) {
        const queue = JSON.parse(stored);
        setSyncQueue(queue);
      }
    } catch (_error) {}
  }, []);

  // Process sync queue when coming back online
  const processSyncQueue = useCallback(async () => {
    if (!networkStatus.isOnline || syncQueue.length === 0 || isSyncing) {
      return;
    }

    setIsSyncing(true);

    try {
      const updatedQueue = [...syncQueue];

      for (let i = updatedQueue.length - 1; i >= 0; i--) {
        const item = updatedQueue[i];

        try {
          const response = await fetch(item.url, {
            method: item.method,
            headers: {
              'Content-Type': 'application/json',
            },
            body: item.data ? JSON.stringify(item.data) : undefined,
          });

          if (response.ok) {
            // Success - remove from queue
            updatedQueue.splice(i, 1);
          } else {
            // Failed - increment retry count
            item.retryCount = (item.retryCount || 0) + 1;

            // Remove after 3 failed attempts
            if (item.retryCount >= 3) {
              updatedQueue.splice(i, 1);
            }
          }
        } catch (_error) {
          // Network error - increment retry count
          item.retryCount = (item.retryCount || 0) + 1;

          if (item.retryCount >= 3) {
            updatedQueue.splice(i, 1);
          }
        }
      }

      // Update state and localStorage
      setSyncQueue(updatedQueue);
      localStorage.setItem('neonpro-sync-queue', JSON.stringify(updatedQueue));
    } catch (_error) {
    } finally {
      setIsSyncing(false);
    }
  }, [networkStatus.isOnline, syncQueue, isSyncing]);

  // Add item to sync queue
  const addToSyncQueue = useCallback(
    (item: Omit<SyncQueueItem, 'id' | 'timestamp' | 'retryCount'>) => {
      const queueItem: SyncQueueItem = {
        ...item,
        id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        timestamp: Date.now(),
        retryCount: 0,
      };

      setSyncQueue((prev) => {
        const newQueue = [...prev, queueItem];
        localStorage.setItem('neonpro-sync-queue', JSON.stringify(newQueue));
        return newQueue;
      });

      return queueItem.id;
    },
    []
  );

  // Clear sync queue
  const clearSyncQueue = useCallback(() => {
    setSyncQueue([]);
    localStorage.removeItem('neonpro-sync-queue');
  }, []);

  // Initialize hook
  useEffect(() => {
    updateNetworkStatus();
    loadSyncQueue();

    // Event listeners
    window.addEventListener('online', updateNetworkStatus);
    window.addEventListener('offline', updateNetworkStatus);

    // Connection change listener (if available)
    const connection = (navigator as any).connection;
    if (connection) {
      connection.addEventListener('change', updateNetworkStatus);
    }

    return () => {
      window.removeEventListener('online', updateNetworkStatus);
      window.removeEventListener('offline', updateNetworkStatus);

      if (connection) {
        connection.removeEventListener('change', updateNetworkStatus);
      }
    };
  }, [updateNetworkStatus, loadSyncQueue]);

  // Process queue when coming online
  useEffect(() => {
    if (networkStatus.isOnline && syncQueue.length > 0) {
      // Small delay to ensure connection is stable
      const timer = setTimeout(() => {
        processSyncQueue();
      }, 1000);

      return () => clearTimeout(timer);
    }
  }, [networkStatus.isOnline, syncQueue.length, processSyncQueue]);

  return {
    ...networkStatus,
    syncQueue,
    syncQueueCount: syncQueue.length,
    isSyncing,
    addToSyncQueue,
    clearSyncQueue,
    processSyncQueue,
  };
}

// Utility hook for offline-first API calls
export function useOfflineApi() {
  const { isOnline, addToSyncQueue } = useNetworkStatus();

  const makeRequest = useCallback(
    async (url: string, options: RequestInit = {}): Promise<Response | null> => {
      if (isOnline) {
        try {
          const response = await fetch(url, options);
          return response;
        } catch (error) {
          // Add to sync queue if it's a safe method to retry
          if (options.method && ['POST', 'PUT', 'PATCH', 'DELETE'].includes(options.method)) {
            addToSyncQueue({
              method: options.method,
              url,
              data: options.body ? JSON.parse(options.body as string) : undefined,
            });
          }

          throw error;
        }
      } else {
        // Offline - add to sync queue if it's a write operation
        if (options.method && ['POST', 'PUT', 'PATCH', 'DELETE'].includes(options.method)) {
          addToSyncQueue({
            method: options.method,
            url,
            data: options.body ? JSON.parse(options.body as string) : undefined,
          });

          // Return a mock successful response for UI feedback
          return new Response(
            JSON.stringify({
              success: true,
              offline: true,
              message: 'Ação salva para sincronização',
            }),
            {
              status: 200,
              statusText: 'OK (Offline)',
              headers: { 'Content-Type': 'application/json' },
            }
          );
        }

        // For read operations, return null to indicate offline
        return null;
      }
    },
    [isOnline, addToSyncQueue]
  );

  return {
    makeRequest,
    isOnline,
  };
}
