/**
 * Session Management Hooks
 * Story 1.4: Session Management & Security
 *
 * React hooks for session management, security monitoring,
 * and device tracking with real-time updates.
 */

// import { useRouter } from '../placeholders/next-navigation'; // Removed - not needed in domain package
import { useCallback, useEffect, useRef, useState } from 'react';
import { useToast } from '../use-toast-mock';
// import { sessionManager } // Missing module - placeholder needed // Comentado - não disponível no domain
// import { logger } // Missing module - placeholder needed // Comentado - não disponível no domain
import type {
  CreateSessionRequest,
  DeviceRegistration,
  SecurityEventType,
  SessionAnalytics,
  SessionSecurityEvent,
  UpdateSessionRequest,
  UserSession,
} from '../../types/session';

// Mock implementations para o pacote domain
const sessionManager = {
  createSession: async (request: CreateSessionRequest) => ({ id: 'mock', userId: 'mock' } as UserSession),
  updateSession: async (updates: UpdateSessionRequest) => {},
  terminateSession: async (reason?: string) => {},
  terminateAllSessions: async () => {},
  refreshSession: async () => ({ id: 'mock', userId: 'mock' } as UserSession),
  extendSession: async () => {},
  reportSuspiciousActivity: async (eventType: SecurityEventType, details?: any) => {},
  trustDevice: async (deviceId: string) => {},
  blockDevice: async (deviceId: string) => {},
  getSecurityEvents: async () => [] as SessionSecurityEvent[],
  getDevices: async () => [] as DeviceRegistration[],
  getAnalytics: async () => null as SessionAnalytics | null,
};

const logger = {
  info: (message: string, data?: any) => console.log(message, data),
  warn: (message: string, data?: any) => console.warn(message, data),
  error: (message: string, data?: any) => console.error(message, data),
};

// ============================================================================
// SESSION HOOK
// ============================================================================

export type UseSessionReturn = {
  session: UserSession | null;
  isLoading: boolean;
  isAuthenticated: boolean;
  securityEvents: SessionSecurityEvent[];
  devices: DeviceRegistration[];
  analytics: SessionAnalytics | null;
  createSession: (request: CreateSessionRequest) => Promise<UserSession>;
  updateSession: (updates: UpdateSessionRequest) => Promise<void>;
  terminateSession: (reason?: string) => Promise<void>;
  terminateAllSessions: () => Promise<void>;
  refreshSession: () => Promise<void>;
  extendSession: () => Promise<void>;
  reportSuspiciousActivity: (eventType: SecurityEventType, details?: any) => Promise<void>;
  trustDevice: (deviceId: string) => Promise<void>;
  blockDevice: (deviceId: string) => Promise<void>;
  error: string | null;
};

export function useSession(): UseSessionReturn {
  const [session, setSession] = useState<UserSession | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [securityEvents, setSecurityEvents] = useState<SessionSecurityEvent[]>([]);
  const [devices, setDevices] = useState<DeviceRegistration[]>([]);
  const [analytics, setAnalytics] = useState<SessionAnalytics | null>(null);
  const [error, setError] = useState<string | null>(null);

  // const router = useRouter(); // Removed - not needed in domain package
  const { toast } = useToast();
  const heartbeatRef = useRef<NodeJS.Timeout | null>(null);
  const securityMonitorRef = useRef<NodeJS.Timeout | null>(null);

  // ============================================================================
  // SESSION MANAGEMENT
  // ============================================================================

  const createSession = useCallback(
    async (request: CreateSessionRequest): Promise<UserSession> => {
      try {
        setIsLoading(true);
        setError(null);

        const newSession = await sessionManager.createSession(request);
        setSession(newSession);

        // Start session monitoring
        startSessionMonitoring(newSession);

        // Load related data
        await Promise.all([
          loadSecurityEvents(newSession.id),
          loadUserDevices(newSession.user_id),
          loadSessionAnalytics(newSession.user_id),
        ]);

        toast({
          title: 'Session Created',
          description: 'You have been successfully logged in.',
          variant: 'default',
        });

        logger.info('Session created via hook', { session_id: newSession.id });
        return newSession;
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Failed to create session';
        setError(errorMessage);

        toast({
          title: 'Login Failed',
          description: errorMessage,
          variant: 'destructive',
        });

        throw err;
      } finally {
        setIsLoading(false);
      }
    },
    [
      toast,
      loadSecurityEvents,
      loadSessionAnalytics,
      loadUserDevices, // Start session monitoring
      startSessionMonitoring,
    ]
  );

  const updateSession = useCallback(
    async (updates: UpdateSessionRequest): Promise<void> => {
      if (!session) {
        return;
      }

      try {
        const updatedSession = await sessionManager.updateSession(session.id, updates);
        setSession(updatedSession);

        logger.info('Session updated via hook', {
          session_id: session.id,
          updates,
        });
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Failed to update session';
        setError(errorMessage);
        logger.error('Session update failed', {
          error: err,
          session_id: session.id,
        });
      }
    },
    [session]
  );

  const terminateSession = useCallback(
    async (reason = 'user_logout'): Promise<void> => {
      if (!session) {
        return;
      }

      try {
        setIsLoading(true);

        await sessionManager.terminateSession(session.id, reason);

        // Stop monitoring
        stopSessionMonitoring();

        // Clear state
        setSession(null);
        setSecurityEvents([]);
        setDevices([]);
        setAnalytics(null);
        setError(null);

        toast({
          title: 'Session Ended',
          description: 'You have been successfully logged out.',
          variant: 'default',
        });

        // Redirect to login - handled by parent component
        // router.push('/auth/login');

        logger.info('Session terminated via hook', {
          session_id: session.id,
          reason,
        });
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Failed to terminate session';
        setError(errorMessage);

        toast({
          title: 'Logout Failed',
          description: errorMessage,
          variant: 'destructive',
        });
      } finally {
        setIsLoading(false);
      }
    },
    [
      session,
      toast, // Stop monitoring
      stopSessionMonitoring,
    ]
  );

  const terminateAllSessions = useCallback(async (): Promise<void> => {
    if (!session) {
      return;
    }

    try {
      setIsLoading(true);

      // Get all active sessions for user
      const { data: activeSessions } = await sessionManager.supabase
        .from('user_sessions')
        .select('id')
        .eq('user_id', session.user_id)
        .eq('is_active', true);

      if (activeSessions) {
        // Terminate all sessions
        await Promise.all(
          activeSessions.map((s) => sessionManager.terminateSession(s.id, 'terminate_all_sessions'))
        );
      }

      // Stop monitoring
      stopSessionMonitoring();

      // Clear state
      setSession(null);
      setSecurityEvents([]);
      setDevices([]);
      setAnalytics(null);
      setError(null);

      toast({
        title: 'All Sessions Terminated',
        description: 'All active sessions have been terminated for security.',
        variant: 'default',
      });

      // Redirect to login
      router.push('/auth/login');

      logger.info('All sessions terminated via hook', {
        user_id: session.user_id,
      });
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to terminate all sessions';
      setError(errorMessage);

      toast({
        title: 'Termination Failed',
        description: errorMessage,
        variant: 'destructive',
      });
    } finally {
      setIsLoading(false);
    }
  }, [
    session,
    router,
    toast, // Stop monitoring
    stopSessionMonitoring,
  ]);

  const refreshSession = useCallback(async (): Promise<void> => {
    if (!session) {
      return;
    }

    try {
      // Get current session from database
      const { data: currentSession } = await sessionManager.supabase
        .from('user_sessions')
        .select('*')
        .eq('id', session.id)
        .eq('is_active', true)
        .single();

      if (currentSession) {
        setSession(currentSession);

        // Refresh related data
        await Promise.all([
          loadSecurityEvents(currentSession.id),
          loadUserDevices(currentSession.user_id),
          loadSessionAnalytics(currentSession.user_id),
        ]);
      } else {
        // Session no longer exists or is inactive
        await terminateSession('session_expired');
      }
    } catch (err) {
      logger.error('Session refresh failed', {
        error: err,
        session_id: session.id,
      });
      setError('Failed to refresh session');
    }
  }, [session, terminateSession, loadSecurityEvents, loadSessionAnalytics, loadUserDevices]);

  const extendSession = useCallback(async (): Promise<void> => {
    if (!session) {
      return;
    }

    try {
      await updateSession({
        last_activity: new Date().toISOString(),
      });

      logger.info('Session extended via hook', { session_id: session.id });
    } catch (err) {
      logger.error('Session extension failed', {
        error: err,
        session_id: session.id,
      });
    }
  }, [session, updateSession]);

  // ============================================================================
  // DATA LOADING (moved above)
  // ============================================================================

  // ============================================================================
  // SECURITY MONITORING
  // ============================================================================

  const reportSuspiciousActivity = useCallback(
    async (eventType: SecurityEventType, details?: any): Promise<void> => {
      if (!session) {
        return;
      }

      try {
        // Create security event
        // Mock implementation - sessionManager não tem supabase no domain
        await sessionManager.reportSuspiciousActivity(eventType, {
          ...details,
          session_id: session.id,
          user_id: session.userId,
          ip_address: session.ipAddress,
          user_agent: session.userAgent,
          reported_by: 'user',
          timestamp: new Date().toISOString(),
        });

        // Reload security events
        await loadSecurityEvents(session.id);

        toast({
          title: 'Security Event Reported',
          description: 'Suspicious activity has been reported and logged.',
          variant: 'default',
        });

        logger.warn('Suspicious activity reported via hook', {
          session_id: session.id,
          event_type: eventType,
          details,
        });
      } catch (err) {
        const errorMessage =
          err instanceof Error ? err.message : 'Failed to report suspicious activity';
        setError(errorMessage);

        toast({
          title: 'Report Failed',
          description: errorMessage,
          variant: 'destructive',
        });
      }
    },
    [session, toast, loadSecurityEvents]
  );

  // ============================================================================
  // DEVICE MANAGEMENT
  // ============================================================================

  const trustDevice = useCallback(
    async (deviceId: string): Promise<void> => {
      try {
        await sessionManager.supabase
          .from('device_registrations')
          .update({ trusted: true })
          .eq('id', deviceId);

        // Reload devices
        if (session) {
          await loadUserDevices(session.user_id);
        }

        toast({
          title: 'Device Trusted',
          description: 'Device has been marked as trusted.',
          variant: 'default',
        });

        logger.info('Device trusted via hook', { device_id: deviceId });
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Failed to trust device';
        setError(errorMessage);

        toast({
          title: 'Trust Failed',
          description: errorMessage,
          variant: 'destructive',
        });
      }
    },
    [session, toast, loadUserDevices]
  );

  const blockDevice = useCallback(
    async (deviceId: string): Promise<void> => {
      try {
        await sessionManager.supabase
          .from('device_registrations')
          .update({ blocked: true })
          .eq('id', deviceId);

        // Terminate any active sessions from this device
        const { data: deviceSessions } = await sessionManager.supabase
          .from('user_sessions')
          .select('id')
          .eq('device_fingerprint', devices.find((d) => d.id === deviceId)?.device_fingerprint)
          .eq('is_active', true);

        if (deviceSessions) {
          await Promise.all(
            deviceSessions.map((s) => sessionManager.terminateSession(s.id, 'device_blocked'))
          );
        }

        // Reload devices
        if (session) {
          await loadUserDevices(session.user_id);
        }

        toast({
          title: 'Device Blocked',
          description: 'Device has been blocked and all sessions terminated.',
          variant: 'default',
        });

        logger.info('Device blocked via hook', { device_id: deviceId });
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Failed to block device';
        setError(errorMessage);

        toast({
          title: 'Block Failed',
          description: errorMessage,
          variant: 'destructive',
        });
      }
    },
    [session, devices, toast, loadUserDevices]
  );

  // ============================================================================
  // DATA LOADING
  // ============================================================================

  const loadSecurityEvents = useCallback(async (sessionId: string): Promise<void> => {
    try {
      // Mock implementation - usando sessionManager mock
      const events = await sessionManager.getSecurityEvents();
      setSecurityEvents(events || []);
    } catch (err) {
      logger.error('Failed to load security events', {
        error: err,
        session_id: sessionId,
      });
    }
  }, []);

  const loadUserDevices = useCallback(async (userId: string): Promise<void> => {
    try {
      const { data: userDevices } = await sessionManager.supabase
        .from('device_registrations')
        .select('*')
        .eq('user_id', userId)
        .order('last_seen', { ascending: false });

      setDevices(userDevices || []);
    } catch (err) {
      logger.error('Failed to load user devices', {
        error: err,
        user_id: userId,
      });
    }
  }, []);

  const loadSessionAnalytics = useCallback(async (userId: string): Promise<void> => {
    try {
      // Get session analytics from last 30 days
      const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString();

      const { data: sessions } = await sessionManager.supabase
        .from('user_sessions')
        .select('*')
        .eq('user_id', userId)
        .gte('created_at', thirtyDaysAgo);

      if (sessions) {
        const analytics: SessionAnalytics = {
          total_sessions: sessions.length,
          active_sessions: sessions.filter((s) => s.is_active).length,
          average_duration_minutes: 0,
          unique_devices: new Set(sessions.map((s) => s.device_fingerprint)).size,
          unique_locations: new Set(sessions.map((s) => s.ip_address)).size,
          security_events_count: 0,
          last_login: sessions.length > 0 ? sessions[0].created_at : null,
          most_used_device: '',
          risk_score: 0,
        };

        // Calculate average duration
        const completedSessions = sessions.filter((s) => !s.is_active);
        if (completedSessions.length > 0) {
          const totalDuration = completedSessions.reduce((sum, session) => {
            const start = new Date(session.created_at).getTime();
            const end = new Date(session.expires_at).getTime();
            return sum + (end - start);
          }, 0);
          analytics.average_duration_minutes = Math.round(
            totalDuration / completedSessions.length / 60_000
          );
        }

        // Get security events count
        const { count: securityCount } = await sessionManager.supabase
          .from('session_security_events')
          .select('*', { count: 'exact', head: true })
          .eq('user_id', userId)
          .gte('timestamp', thirtyDaysAgo);

        analytics.security_events_count = securityCount || 0;

        // Calculate risk score (simplified)
        analytics.risk_score = Math.min(
          100,
          analytics.security_events_count * 10 +
            (analytics.unique_locations > 5 ? 20 : 0) +
            (analytics.unique_devices > 3 ? 15 : 0)
        );

        setAnalytics(analytics);
      }
    } catch (err) {
      logger.error('Failed to load session analytics', {
        error: err,
        user_id: userId,
      });
    }
  }, []);

  // ============================================================================
  // SESSION MONITORING
  // ============================================================================

  const startSessionMonitoring = useCallback(
    (sessionData: UserSession): void => {
      // Heartbeat to keep session alive
      heartbeatRef.current = setInterval(
        () => {
          extendSession();
        },
        5 * 60 * 1000
      ); // Every 5 minutes

      // Security monitoring
      securityMonitorRef.current = setInterval(() => {
        if (sessionData.id) {
          loadSecurityEvents(sessionData.id);
        }
      }, 30 * 1000); // Every 30 seconds

      logger.info('Session monitoring started', { session_id: sessionData.id });
    },
    [extendSession, loadSecurityEvents]
  );

  const stopSessionMonitoring = useCallback((): void => {
    if (heartbeatRef.current) {
      clearInterval(heartbeatRef.current);
      heartbeatRef.current = null;
    }

    if (securityMonitorRef.current) {
      clearInterval(securityMonitorRef.current);
      securityMonitorRef.current = null;
    }

    logger.info('Session monitoring stopped');
  }, []);

  // ============================================================================
  // EFFECTS
  // ============================================================================

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      stopSessionMonitoring();
    };
  }, [stopSessionMonitoring]);

  // Auto-refresh session periodically
  useEffect(() => {
    if (session) {
      const refreshInterval = setInterval(
        () => {
          refreshSession();
        },
        10 * 60 * 1000
      ); // Every 10 minutes

      return () => clearInterval(refreshInterval);
    }
  }, [session, refreshSession]);

  return {
    session,
    isLoading,
    isAuthenticated: Boolean(session?.is_active),
    securityEvents,
    devices,
    analytics,
    createSession,
    updateSession,
    terminateSession,
    terminateAllSessions,
    refreshSession,
    extendSession,
    reportSuspiciousActivity,
    trustDevice,
    blockDevice,
    error,
  };
}

// ============================================================================
// SECURITY EVENTS HOOK
// ============================================================================

export type UseSecurityEventsReturn = {
  events: SessionSecurityEvent[];
  isLoading: boolean;
  resolveEvent: (eventId: string) => Promise<void>;
  dismissEvent: (eventId: string) => Promise<void>;
  getEventsByType: (eventType: SecurityEventType) => SessionSecurityEvent[];
  getUnresolvedEvents: () => SessionSecurityEvent[];
  getCriticalEvents: () => SessionSecurityEvent[];
  error: string | null;
};

export function useSecurityEvents(sessionId?: string): UseSecurityEventsReturn {
  const [events, setEvents] = useState<SessionSecurityEvent[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const { toast } = useToast();

  const loadEvents = useCallback(async (): Promise<void> => {
    if (!sessionId) {
      return;
    }

    try {
      setIsLoading(true);
      setError(null);

      const { data: securityEvents, error: loadError } = await sessionManager.supabase
        .from('session_security_events')
        .select('*')
        .eq('session_id', sessionId)
        .order('timestamp', { ascending: false });

      if (loadError) {
        throw loadError;
      }

      setEvents(securityEvents || []);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to load security events';
      setError(errorMessage);
      logger.error('Failed to load security events', {
        error: err,
        session_id: sessionId,
      });
    } finally {
      setIsLoading(false);
    }
  }, [sessionId]);

  const resolveEvent = useCallback(
    async (eventId: string): Promise<void> => {
      try {
        await sessionManager.supabase
          .from('session_security_events')
          .update({
            resolved: true,
            resolved_at: new Date().toISOString(),
          })
          .eq('id', eventId);

        // Reload events
        await loadEvents();

        toast({
          title: 'Event Resolved',
          description: 'Security event has been marked as resolved.',
          variant: 'default',
        });
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Failed to resolve event';
        setError(errorMessage);

        toast({
          title: 'Resolution Failed',
          description: errorMessage,
          variant: 'destructive',
        });
      }
    },
    [loadEvents, toast]
  );

  const dismissEvent = useCallback(
    async (eventId: string): Promise<void> => {
      try {
        await sessionManager.supabase
          .from('session_security_events')
          .update({
            resolved: true,
            resolved_at: new Date().toISOString(),
            details: { dismissed: true },
          })
          .eq('id', eventId);

        // Reload events
        await loadEvents();

        toast({
          title: 'Event Dismissed',
          description: 'Security event has been dismissed.',
          variant: 'default',
        });
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Failed to dismiss event';
        setError(errorMessage);

        toast({
          title: 'Dismissal Failed',
          description: errorMessage,
          variant: 'destructive',
        });
      }
    },
    [loadEvents, toast]
  );

  const getEventsByType = useCallback(
    (eventType: SecurityEventType): SessionSecurityEvent[] => {
      return events.filter((event) => event.event_type === eventType);
    },
    [events]
  );

  const getUnresolvedEvents = useCallback((): SessionSecurityEvent[] => {
    return events.filter((event) => !event.resolved);
  }, [events]);

  const getCriticalEvents = useCallback((): SessionSecurityEvent[] => {
    return events.filter((event) => event.severity === 'critical' && !event.resolved);
  }, [events]);

  // Load events when sessionId changes
  useEffect(() => {
    if (sessionId) {
      loadEvents();
    }
  }, [sessionId, loadEvents]);

  return {
    events,
    isLoading,
    resolveEvent,
    dismissEvent,
    getEventsByType,
    getUnresolvedEvents,
    getCriticalEvents,
    error,
  };
}
