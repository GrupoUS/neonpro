/**
 * Vision Analysis Configuration Hook for NeonPro
 *
 * Custom hook for managing computer vision analysis configuration and user preferences.
 * Provides functionality for:
 * - Loading and updating user-specific configurations
 * - Managing analysis thresholds and processing settings
 * - Handling notification and export preferences
 * - Privacy and sharing settings management
 * - Advanced feature toggles
 *
 * Integrates with the vision config API and provides real-time updates.
 */

import { useCallback, useEffect, useState } from 'react';
import { toast } from '../placeholders/sonner';

// Configuration interfaces
export type VisionAnalysisConfig = {
  // Analysis thresholds
  accuracyThreshold: number;
  confidenceThreshold: number;
  processingTimeLimit: number;

  // Image processing settings
  imageProcessing: {
    maxResolution: number;
    compressionQuality: number;
    enablePreprocessing: boolean;
    autoEnhancement: boolean;
  };

  // Notification preferences
  notifications: {
    analysisComplete: boolean;
    lowAccuracyAlert: boolean;
    processingTimeAlert: boolean;
    emailNotifications: boolean;
  };

  // Export preferences
  export: {
    defaultFormat: 'json' | 'csv' | 'pdf' | 'excel';
    includeImages: boolean;
    includeAnnotations: boolean;
    includeMetrics: boolean;
    autoExport: boolean;
  };

  // Privacy settings
  privacy: {
    dataRetentionDays: number;
    allowAnalytics: boolean;
    shareWithResearch: boolean;
    anonymizeExports: boolean;
  };

  // Advanced features
  advanced: {
    enableBatchProcessing: boolean;
    useGPUAcceleration: boolean;
    enableRealTimeAnalysis: boolean;
    customModelPath?: string;
  };
};

export type VisionConfigState = {
  config: VisionAnalysisConfig | null;
  isLoading: boolean;
  error: string | null;
  hasUnsavedChanges: boolean;
};

export type VisionConfigActions = {
  loadConfig: () => Promise<void>;
  updateConfig: (updates: Partial<VisionAnalysisConfig>) => Promise<void>;
  resetToDefaults: () => Promise<void>;
  saveConfig: () => Promise<void>;
  discardChanges: () => void;
};

export interface UseVisionConfigReturn extends VisionConfigState, VisionConfigActions {}

// Default configuration
const DEFAULT_CONFIG: VisionAnalysisConfig = {
  accuracyThreshold: 0.85,
  confidenceThreshold: 0.8,
  processingTimeLimit: 30_000, // 30 seconds

  imageProcessing: {
    maxResolution: 2048,
    compressionQuality: 0.9,
    enablePreprocessing: true,
    autoEnhancement: true,
  },

  notifications: {
    analysisComplete: true,
    lowAccuracyAlert: true,
    processingTimeAlert: true,
    emailNotifications: false,
  },

  export: {
    defaultFormat: 'json',
    includeImages: true,
    includeAnnotations: true,
    includeMetrics: true,
    autoExport: false,
  },

  privacy: {
    dataRetentionDays: 365,
    allowAnalytics: true,
    shareWithResearch: false,
    anonymizeExports: true,
  },

  advanced: {
    enableBatchProcessing: false,
    useGPUAcceleration: true,
    enableRealTimeAnalysis: false,
  },
};

export function useVisionConfig(): UseVisionConfigReturn {
  const [state, setState] = useState<VisionConfigState>({
    config: null,
    isLoading: false,
    error: null,
    hasUnsavedChanges: false,
  });

  const [originalConfig, setOriginalConfig] = useState<VisionAnalysisConfig | null>(null);

  /**
   * Load configuration from API
   */
  const loadConfig = useCallback(async () => {
    setState((prev) => ({ ...prev, isLoading: true, error: null }));

    try {
      const response = await fetch('/api/vision/config');

      if (!response.ok) {
        throw new Error('Failed to load configuration');
      }

      const data = await response.json();
      const config = data.config || DEFAULT_CONFIG;

      setState((prev) => ({
        ...prev,
        config,
        isLoading: false,
        hasUnsavedChanges: false,
      }));

      setOriginalConfig(config);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to load configuration';
      setState((prev) => ({
        ...prev,
        error: errorMessage,
        isLoading: false,
      }));
      toast.error('Failed to load configuration');
    }
  }, []);

  /**
   * Update configuration (local state only)
   */
  const updateConfig = useCallback(
    async (updates: Partial<VisionAnalysisConfig>) => {
      setState((prev) => {
        if (!prev.config) {
          return prev;
        }

        const newConfig = { ...prev.config, ...updates };
        const hasChanges = JSON.stringify(newConfig) !== JSON.stringify(originalConfig);

        return {
          ...prev,
          config: newConfig,
          hasUnsavedChanges: hasChanges,
        };
      });
    },
    [originalConfig]
  );

  /**
   * Save configuration to API
   */
  const saveConfig = useCallback(async () => {
    if (!state.config) {
      toast.error('No configuration to save');
      return;
    }

    setState((prev) => ({ ...prev, isLoading: true, error: null }));

    try {
      const response = await fetch('/api/vision/config', {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ config: state.config }),
      });

      if (!response.ok) {
        throw new Error('Failed to save configuration');
      }

      setState((prev) => ({
        ...prev,
        isLoading: false,
        hasUnsavedChanges: false,
      }));

      setOriginalConfig(state.config);
      toast.success('Configuration saved successfully');
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to save configuration';
      setState((prev) => ({
        ...prev,
        error: errorMessage,
        isLoading: false,
      }));
      toast.error('Failed to save configuration');
    }
  }, [state.config]);

  /**
   * Reset configuration to defaults
   */
  const resetToDefaults = useCallback(async () => {
    setState((prev) => ({ ...prev, isLoading: true, error: null }));

    try {
      const response = await fetch('/api/vision/config', {
        method: 'POST',
      });

      if (!response.ok) {
        throw new Error('Failed to reset configuration');
      }

      const data = await response.json();
      const config = data.config || DEFAULT_CONFIG;

      setState((prev) => ({
        ...prev,
        config,
        isLoading: false,
        hasUnsavedChanges: false,
      }));

      setOriginalConfig(config);
      toast.success('Configuration reset to defaults');
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to reset configuration';
      setState((prev) => ({
        ...prev,
        error: errorMessage,
        isLoading: false,
      }));
      toast.error('Failed to reset configuration');
    }
  }, []);

  /**
   * Discard unsaved changes
   */
  const discardChanges = useCallback(() => {
    if (originalConfig) {
      setState((prev) => ({
        ...prev,
        config: originalConfig,
        hasUnsavedChanges: false,
        error: null,
      }));

      toast.success('Changes discarded');
    }
  }, [originalConfig]);

  // Load configuration on mount
  useEffect(() => {
    loadConfig();
  }, [loadConfig]);

  return {
    ...state,
    loadConfig,
    updateConfig,
    resetToDefaults,
    saveConfig,
    discardChanges,
  };
}

export default useVisionConfig;
