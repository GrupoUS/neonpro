/**
 * React Hook for RBAC Permissions Management
 * Story 1.2: Role-Based Access Control Implementation
 *
 * This hook provides permission checking and role management for React components
 */

import { useCallback, useEffect, useMemo, useState } from 'react';
// import { useAuth } // PLACEHOLDER: from '@/contexts/auth-context'; // PLACEHOLDER - NEEDS FIXING
// import type { Permission, PermissionResult, UserRole } // PLACEHOLDER: from '@/types/rbac'; // PLACEHOLDER - NEEDS FIXING

/**
 * Permission check cache for frontend optimization
 */
type PermissionCache = {
  [key: string]: {
    result: PermissionResult;
    timestamp: number;
  };
};

const permissionCache: PermissionCache = {};
const CACHE_TTL = 2 * 60 * 1000; // 2 minutes for frontend cache

/**
 * Permission hook return type
 */
export type UsePermissionsReturn = {
  // Permission checking functions
  hasPermission: (permission: Permission, resourceId?: string) => Promise<boolean>;
  hasAnyPermission: (permissions: Permission[], resourceId?: string) => Promise<boolean>;
  hasAllPermissions: (permissions: Permission[], resourceId?: string) => Promise<boolean>;
  hasRole: (role: UserRole) => boolean;
  hasMinimumRole: (minimumRole: UserRole) => boolean;

  // Permission state
  permissions: Permission[];
  role: UserRole | null;
  isLoading: boolean;
  error: string | null;

  // Utility functions
  canAccess: (feature: string) => boolean;
  canManage: (resource: string) => boolean;
  canView: (resource: string) => boolean;

  // Cache management
  clearCache: () => void;
  refreshPermissions: () => Promise<void>;
};

/**
 * Role hierarchy for comparison
 */
const ROLE_HIERARCHY: Record<UserRole, number> = {
  patient: 1,
  staff: 2,
  manager: 3,
  owner: 4,
};

/**
 * Feature permission mapping
 */
const FEATURE_PERMISSIONS: Record<string, Permission[]> = {
  patients: ['patients.read', 'patients.manage'],
  appointments: ['appointments.read', 'appointments.manage'],
  billing: ['billing.read', 'billing.manage'],
  payments: ['payments.read', 'payments.manage'],
  users: ['users.read', 'users.manage'],
  clinic: ['clinic.read', 'clinic.manage'],
  system: ['system.admin'],
  reports: ['reports.read', 'reports.generate'],
  audit: ['audit.read'],
};

/**
 * Main permissions hook
 */
export function usePermissions(): UsePermissionsReturn {
  const { user, isLoading: authLoading } = useAuth();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [_userPermissions, _setUserPermissions] = useState<Permission[]>([]);

  /**
   * Get user's role
   */
  const role = useMemo(() => {
    return (user?.role as UserRole) || null;
  }, [user?.role]);

  /**
   * Get user's permissions based on role
   */
  const permissions = useMemo(() => {
    if (!(role && user)) {
      return [];
    }

    // Import DEFAULT_ROLES from types (would need to be imported)
    // For now, we'll define basic permissions here
    const rolePermissions: Record<UserRole, Permission[]> = {
      patient: ['patients.read'],
      staff: ['patients.read', 'patients.manage', 'appointments.read', 'appointments.manage'],
      manager: [
        'patients.read',
        'patients.manage',
        'appointments.read',
        'appointments.manage',
        'billing.read',
        'billing.manage',
        'payments.read',
        'payments.manage',
        'users.read',
        'users.manage',
        'reports.read',
        'reports.generate',
      ],
      owner: [
        'patients.read',
        'patients.manage',
        'appointments.read',
        'appointments.manage',
        'billing.read',
        'billing.manage',
        'payments.read',
        'payments.manage',
        'users.read',
        'users.manage',
        'clinic.read',
        'clinic.manage',
        'reports.read',
        'reports.generate',
        'audit.read',
      ],
    };

    return rolePermissions[role] || [];
  }, [role, user]);

  /**
   * Generate cache key
   */
  const getCacheKey = useCallback(
    (permission: Permission, resourceId?: string): string => {
      return `${user?.id}:${permission}:${resourceId || 'global'}:${user?.clinicId}`;
    },
    [user?.id, user?.clinicId]
  );

  /**
   * Clear expired cache entries
   */
  const clearExpiredCache = useCallback(() => {
    const now = Date.now();
    Object.keys(permissionCache).forEach((key) => {
      if (now - permissionCache[key].timestamp > CACHE_TTL) {
        delete permissionCache[key];
      }
    });
  }, []);

  /**
   * Check if user has specific permission
   */
  const hasPermission = useCallback(
    async (permission: Permission, resourceId?: string): Promise<boolean> => {
      if (!(user && role)) {
        return false;
      }

      // Check cache first
      const cacheKey = getCacheKey(permission, resourceId);
      const cached = permissionCache[cacheKey];
      if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
        return cached.result.granted;
      }

      try {
        setError(null);

        // For frontend, we'll do basic role-based checking
        // In a real implementation, this would call the backend API
        const hasRolePermission = permissions.includes(permission);

        if (!hasRolePermission) {
          const result: PermissionResult = {
            granted: false,
            reason: `Role '${role}' does not have permission '${permission}'`,
            roleUsed: role,
          };

          permissionCache[cacheKey] = {
            result,
            timestamp: Date.now(),
          };

          return false;
        }

        // Additional resource-specific checks would go here
        // For now, we'll assume permission is granted if role has it
        const result: PermissionResult = {
          granted: true,
          roleUsed: role,
        };

        permissionCache[cacheKey] = {
          result,
          timestamp: Date.now(),
        };

        return true;
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Permission check failed';
        setError(errorMessage);
        return false;
      }
    },
    [user, role, permissions, getCacheKey]
  );

  /**
   * Check if user has any of the specified permissions
   */
  const hasAnyPermission = useCallback(
    async (permissionList: Permission[], resourceId?: string): Promise<boolean> => {
      for (const permission of permissionList) {
        if (await hasPermission(permission, resourceId)) {
          return true;
        }
      }
      return false;
    },
    [hasPermission]
  );

  /**
   * Check if user has all specified permissions
   */
  const hasAllPermissions = useCallback(
    async (permissionList: Permission[], resourceId?: string): Promise<boolean> => {
      for (const permission of permissionList) {
        if (!(await hasPermission(permission, resourceId))) {
          return false;
        }
      }
      return true;
    },
    [hasPermission]
  );

  /**
   * Check if user has specific role
   */
  const hasRole = useCallback(
    (targetRole: UserRole): boolean => {
      return role === targetRole;
    },
    [role]
  );

  /**
   * Check if user has minimum role level
   */
  const hasMinimumRole = useCallback(
    (minimumRole: UserRole): boolean => {
      if (!role) {
        return false;
      }
      return ROLE_HIERARCHY[role] >= ROLE_HIERARCHY[minimumRole];
    },
    [role]
  );

  /**
   * Check if user can access a feature
   */
  const canAccess = useCallback(
    (feature: string): boolean => {
      const featurePermissions = FEATURE_PERMISSIONS[feature];
      if (!featurePermissions) {
        return false;
      }

      return featurePermissions.some((permission) => permissions.includes(permission));
    },
    [permissions]
  );

  /**
   * Check if user can manage a resource
   */
  const canManage = useCallback(
    (resource: string): boolean => {
      const managePermission = `${resource}.manage` as Permission;
      return permissions.includes(managePermission);
    },
    [permissions]
  );

  /**
   * Check if user can view a resource
   */
  const canView = useCallback(
    (resource: string): boolean => {
      const readPermission = `${resource}.read` as Permission;
      const managePermission = `${resource}.manage` as Permission;
      return permissions.includes(readPermission) || permissions.includes(managePermission);
    },
    [permissions]
  );

  /**
   * Clear permission cache
   */
  const clearCache = useCallback(() => {
    Object.keys(permissionCache).forEach((key) => {
      if (key.startsWith(`${user?.id}:`)) {
        delete permissionCache[key];
      }
    });
  }, [user?.id]);

  /**
   * Refresh user permissions
   */
  const refreshPermissions = useCallback(async () => {
    if (!user) {
      return;
    }

    setIsLoading(true);
    setError(null);

    try {
      // Clear cache for this user
      clearCache();

      // In a real implementation, this would fetch fresh permissions from the backend
      // For now, we'll just clear the cache and let the next permission check refresh

      // Simulate API call delay
      await new Promise((resolve) => setTimeout(resolve, 100));
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to refresh permissions';
      setError(errorMessage);
    } finally {
      setIsLoading(false);
    }
  }, [user, clearCache]);

  /**
   * Clear expired cache entries periodically
   */
  useEffect(() => {
    const interval = setInterval(clearExpiredCache, 60_000); // Every minute
    return () => clearInterval(interval);
  }, [clearExpiredCache]);

  /**
   * Clear cache when user changes
   */
  useEffect(() => {
    if (user) {
      clearCache();
    }
  }, [user?.id, clearCache, user]);

  return {
    hasPermission,
    hasAnyPermission,
    hasAllPermissions,
    hasRole,
    hasMinimumRole,
    permissions,
    role,
    isLoading: authLoading || isLoading,
    error,
    canAccess,
    canManage,
    canView,
    clearCache,
    refreshPermissions,
  };
}

/**
 * Hook for checking specific permission (simplified)
 */
export function usePermission(permission: Permission, resourceId?: string) {
  const { hasPermission, isLoading, error } = usePermissions();
  const [allowed, setAllowed] = useState<boolean>(false);
  const [checking, setChecking] = useState<boolean>(true);

  useEffect(() => {
    let mounted = true;

    const checkPermission = async () => {
      if (isLoading) {
        return;
      }

      setChecking(true);
      try {
        const result = await hasPermission(permission, resourceId);
        if (mounted) {
          setAllowed(result);
        }
      } catch (_err) {
        if (mounted) {
          setAllowed(false);
        }
      } finally {
        if (mounted) {
          setChecking(false);
        }
      }
    };

    checkPermission();

    return () => {
      mounted = false;
    };
  }, [hasPermission, permission, resourceId, isLoading]);

  return {
    allowed,
    isLoading: isLoading || checking,
    error,
  };
}

/**
 * Hook for role-based access
 */
export function useRole() {
  const { role, hasRole, hasMinimumRole, isLoading, error } = usePermissions();

  return {
    role,
    hasRole,
    hasMinimumRole,
    isOwner: hasRole('owner'),
    isManager: hasMinimumRole('manager'),
    isStaff: hasMinimumRole('staff'),
    isPatient: hasRole('patient'),
    isLoading,
    error,
  };
}
