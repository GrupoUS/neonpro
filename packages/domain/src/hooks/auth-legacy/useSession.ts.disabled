// =====================================================
// useSession Hook - React Session Management
// Story 1.4: Session Management & Security
// =====================================================

import { useRouter } from '../placeholders/next-navigation';
import { useCallback, useEffect, useRef, useState } from 'react';
import { toast } from '../placeholders/sonner';
import { useSupabase } from '@/hooks/useSupabase';
import { type SessionData, UnifiedSessionSystem } // Missing module - placeholder needed

// =====================================================
// TYPES & INTERFACES
// =====================================================

export type SessionState = {
  isLoading: boolean;
  isAuthenticated: boolean;
  user: any | null;
  session: SessionData | null;
  securityScore?: {
    score: number;
    factors: string[];
  };
  error: string | null;
};

export type SessionActions = {
  login: (credentials: LoginCredentials, deviceInfo: DeviceInfo) => Promise<boolean>;
  logout: () => Promise<void>;
  refreshSession: () => Promise<void>;
  extendSession: () => Promise<void>;
  validateSession: () => Promise<boolean>;
  updateActivity: (activityType: string, metadata?: any) => Promise<void>;
};

export type LoginCredentials = {
  email?: string;
  password?: string;
  provider?: string;
  token?: string;
};

export type DeviceInfo = {
  fingerprint: string;
  userAgent: string;
  ipAddress: string;
  location?: string;
};

export type UseSessionOptions = {
  autoRefresh?: boolean;
  refreshInterval?: number;
  redirectOnExpiry?: string;
  showWarnings?: boolean;
  trackActivity?: boolean;
};

export interface UseSessionReturn extends SessionState, SessionActions {
  timeUntilExpiry: number | null;
  isExpiringSoon: boolean;
  sessionStats: {
    duration: number;
    activitiesCount: number;
    lastActivity: Date | null;
  } | null;
}

// =====================================================
// MAIN HOOK
// =====================================================

export function useSession(options: UseSessionOptions = {}): UseSessionReturn {
  const {
    autoRefresh = true,
    refreshInterval = 60_000, // 1 minute
    redirectOnExpiry = '/login',
    showWarnings = true,
    trackActivity = true,
  } = options;

  const { supabase } = useSupabase();
  const router = useRouter();

  // Session system instance
  const sessionSystemRef = useRef<UnifiedSessionSystem | null>(null);

  // State
  const [state, setState] = useState<SessionState>({
    isLoading: true,
    isAuthenticated: false,
    user: null,
    session: null,
    error: null,
  });

  const [timeUntilExpiry, setTimeUntilExpiry] = useState<number | null>(null);
  const [sessionStats, setSessionStats] = useState<{
    duration: number;
    activitiesCount: number;
    lastActivity: Date | null;
  } | null>(null);

  // Refs for intervals
  const refreshIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const expiryTimerRef = useRef<NodeJS.Timeout | null>(null);
  const warningShownRef = useRef(false);

  // =====================================================
  // INITIALIZATION
  // =====================================================

  useEffect(() => {
    if (!supabase) {
      return;
    }

    // Initialize session system
    sessionSystemRef.current = new UnifiedSessionSystem(supabase);
    sessionSystemRef.current.initialize().then(() => {
      // Check for existing session
      checkExistingSession();
    });

    return () => {
      // Cleanup intervals
      if (refreshIntervalRef.current) {
        clearInterval(refreshIntervalRef.current);
      }
      if (expiryTimerRef.current) {
        clearTimeout(expiryTimerRef.current);
      }
    };
  }, [
    supabase, // Check for existing session
    checkExistingSession,
  ]);

  // =====================================================
  // SESSION MANAGEMENT
  // =====================================================

  const checkExistingSession = useCallback(async () => {
    try {
      const sessionId = localStorage.getItem('session_id');
      if (!sessionId) {
        setState((prev) => ({ ...prev, isLoading: false }));
        return;
      }

      const deviceInfo = await getDeviceInfo();
      const validation = await sessionSystemRef.current?.validateSession(
        sessionId,
        deviceInfo.ipAddress,
        deviceInfo.userAgent
      );

      if (validation?.isValid && validation.session) {
        setState({
          isLoading: false,
          isAuthenticated: true,
          user: validation.user,
          session: validation.session,
          securityScore: validation.securityScore,
          error: null,
        });

        // Start auto-refresh if enabled
        if (autoRefresh) {
          startAutoRefresh();
        }

        // Start expiry timer
        startExpiryTimer(validation.session.expiresAt);

        // Update session stats
        updateSessionStats(validation.session);
      } else {
        // Invalid session, clear storage
        localStorage.removeItem('session_id');
        setState((prev) => ({ ...prev, isLoading: false }));
      }
    } catch (error) {
      setState({
        isLoading: false,
        isAuthenticated: false,
        user: null,
        session: null,
        error: error instanceof Error ? error.message : 'Session check failed',
      });
    }
  }, [
    autoRefresh,
    startAutoRefresh, // Start expiry timer
    startExpiryTimer, // Update session stats
    updateSessionStats,
  ]);

  const login = useCallback(
    async (credentials: LoginCredentials, deviceInfo: DeviceInfo): Promise<boolean> => {
      try {
        setState((prev) => ({ ...prev, isLoading: true, error: null }));

        const result = await sessionSystemRef.current?.authenticateUser(credentials, deviceInfo);

        if (result?.success && result.session) {
          // Store session ID
          localStorage.setItem('session_id', result.session.sessionId);

          setState({
            isLoading: false,
            isAuthenticated: true,
            user: result.user,
            session: result.session,
            error: null,
          });

          // Start auto-refresh
          if (autoRefresh) {
            startAutoRefresh();
          }

          // Start expiry timer
          startExpiryTimer(result.session.expiresAt);

          // Update session stats
          updateSessionStats(result.session);

          // Show success message
          if (showWarnings) {
            toast.success('Login successful');

            // Show device warning if needed
            if (!result.deviceValidation?.isTrusted) {
              toast.warning('New device detected. Check your email for security notification.');
            }
          }

          return true;
        }
        setState((prev) => ({
          ...prev,
          isLoading: false,
          error: result?.error || 'Login failed',
        }));

        if (showWarnings) {
          toast.error(result?.error || 'Login failed');
        }

        return false;
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Login failed';
        setState((prev) => ({
          ...prev,
          isLoading: false,
          error: errorMessage,
        }));

        if (showWarnings) {
          toast.error(errorMessage);
        }

        return false;
      }
    },
    [
      autoRefresh,
      showWarnings,
      startAutoRefresh, // Start expiry timer
      startExpiryTimer, // Update session stats
      updateSessionStats,
    ]
  );

  const logout = useCallback(async () => {
    try {
      const sessionId = localStorage.getItem('session_id');
      if (sessionId && sessionSystemRef.current) {
        await sessionSystemRef.current.terminateSession(sessionId, 'user_logout');
      }

      // Clear local storage
      localStorage.removeItem('session_id');

      // Clear intervals
      if (refreshIntervalRef.current) {
        clearInterval(refreshIntervalRef.current);
      }
      if (expiryTimerRef.current) {
        clearTimeout(expiryTimerRef.current);
      }

      // Reset state
      setState({
        isLoading: false,
        isAuthenticated: false,
        user: null,
        session: null,
        error: null,
      });

      setTimeUntilExpiry(null);
      setSessionStats(null);
      warningShownRef.current = false;

      if (showWarnings) {
        toast.success('Logged out successfully');
      }

      // Redirect to login
      router.push(redirectOnExpiry);
    } catch (_error) {
      if (showWarnings) {
        toast.error('Logout failed');
      }
    }
  }, [router, redirectOnExpiry, showWarnings]);

  const refreshSession = useCallback(async () => {
    try {
      const sessionId = localStorage.getItem('session_id');
      if (!sessionId) {
        return;
      }

      const deviceInfo = await getDeviceInfo();
      const validation = await sessionSystemRef.current?.validateSession(
        sessionId,
        deviceInfo.ipAddress,
        deviceInfo.userAgent
      );

      if (validation?.isValid && validation.session) {
        setState((prev) => ({
          ...prev,
          session: validation.session,
          securityScore: validation.securityScore,
          error: null,
        }));

        // Update expiry timer
        startExpiryTimer(validation.session.expiresAt);

        // Update session stats
        updateSessionStats(validation.session);
      } else {
        // Session invalid, logout
        await logout();
      }
    } catch (error) {
      setState((prev) => ({
        ...prev,
        error: error instanceof Error ? error.message : 'Session refresh failed',
      }));
    }
  }, [
    logout, // Update expiry timer
    startExpiryTimer, // Update session stats
    updateSessionStats,
  ]);

  const extendSession = useCallback(async () => {
    try {
      const sessionId = localStorage.getItem('session_id');
      if (!(sessionId && sessionSystemRef.current)) {
        return;
      }

      const result = await sessionSystemRef.current.sessionManager.extendSession(sessionId);

      if (result.success && result.newExpiresAt) {
        setState((prev) => ({
          ...prev,
          session: prev.session
            ? {
                ...prev.session,
                expiresAt: result.newExpiresAt!,
              }
            : null,
        }));

        // Update expiry timer
        startExpiryTimer(result.newExpiresAt);

        if (showWarnings) {
          toast.success('Session extended successfully');
        }
      }
    } catch (_error) {
      if (showWarnings) {
        toast.error('Failed to extend session');
      }
    }
  }, [
    showWarnings, // Update expiry timer
    startExpiryTimer,
  ]);

  const validateSession = useCallback(async (): Promise<boolean> => {
    try {
      const sessionId = localStorage.getItem('session_id');
      if (!sessionId) {
        return false;
      }

      const deviceInfo = await getDeviceInfo();
      const validation = await sessionSystemRef.current?.validateSession(
        sessionId,
        deviceInfo.ipAddress,
        deviceInfo.userAgent
      );

      return validation?.isValid;
    } catch (_error) {
      return false;
    }
  }, []);

  const updateActivity = useCallback(
    async (activityType: string, metadata?: any) => {
      try {
        if (!trackActivity) {
          return;
        }

        const sessionId = localStorage.getItem('session_id');
        if (!(sessionId && sessionSystemRef.current)) {
          return;
        }

        await sessionSystemRef.current.sessionManager.updateActivity(
          sessionId,
          activityType,
          metadata
        );

        // Update session stats
        if (state.session) {
          updateSessionStats(state.session);
        }
      } catch (_error) {}
    },
    [trackActivity, state.session, updateSessionStats]
  );

  // =====================================================
  // HELPER FUNCTIONS
  // =====================================================

  const startAutoRefresh = useCallback(() => {
    if (refreshIntervalRef.current) {
      clearInterval(refreshIntervalRef.current);
    }

    refreshIntervalRef.current = setInterval(() => {
      refreshSession();
    }, refreshInterval);
  }, [refreshSession, refreshInterval]);

  const startExpiryTimer = useCallback(
    (expiresAt: Date) => {
      if (expiryTimerRef.current) {
        clearTimeout(expiryTimerRef.current);
      }

      const updateTimer = () => {
        const now = Date.now();
        const expiry = expiresAt.getTime();
        const timeLeft = expiry - now;

        setTimeUntilExpiry(Math.max(0, timeLeft));

        // Show warning 5 minutes before expiry
        if (timeLeft <= 5 * 60 * 1000 && timeLeft > 0 && !warningShownRef.current && showWarnings) {
          warningShownRef.current = true;
          toast.warning('Your session will expire soon. Click to extend.', {
            action: {
              label: 'Extend Session',
              onClick: extendSession,
            },
            duration: 10_000,
          });
        }

        // Auto logout when expired
        if (timeLeft <= 0) {
          logout();
          return;
        }

        // Schedule next update
        expiryTimerRef.current = setTimeout(updateTimer, 1000);
      };

      updateTimer();
    },
    [logout, extendSession, showWarnings]
  );

  const updateSessionStats = useCallback((session: SessionData) => {
    const now = Date.now();
    const duration = now - session.createdAt.getTime();

    setSessionStats({
      duration,
      activitiesCount: session.activitiesCount || 0,
      lastActivity: session.lastActivity || null,
    });
  }, []);

  // =====================================================
  // COMPUTED VALUES
  // =====================================================

  const isExpiringSoon = timeUntilExpiry !== null && timeUntilExpiry <= 5 * 60 * 1000; // 5 minutes

  // =====================================================
  // RETURN HOOK INTERFACE
  // =====================================================

  return {
    // State
    isLoading: state.isLoading,
    isAuthenticated: state.isAuthenticated,
    user: state.user,
    session: state.session,
    securityScore: state.securityScore,
    error: state.error,

    // Actions
    login,
    logout,
    refreshSession,
    extendSession,
    validateSession,
    updateActivity,

    // Computed
    timeUntilExpiry,
    isExpiringSoon,
    sessionStats,
  };
}

// =====================================================
// UTILITY FUNCTIONS
// =====================================================

/**
 * Get device information for session management
 */
async function getDeviceInfo(): Promise<DeviceInfo> {
  // Generate device fingerprint
  const fingerprint = await generateDeviceFingerprint();

  // Get IP address (in production, this would come from server)
  const ipAddress = await getClientIP();

  return {
    fingerprint,
    userAgent: navigator.userAgent,
    ipAddress,
    location: await getLocation(),
  };
}

/**
 * Generate device fingerprint
 */
async function generateDeviceFingerprint(): Promise<string> {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  ctx?.fillText('Device fingerprint', 10, 10);

  const fingerprint = [
    navigator.userAgent,
    navigator.language,
    `${screen.width}x${screen.height}`,
    new Date().getTimezoneOffset(),
    canvas.toDataURL(),
  ].join('|');

  // Simple hash function
  let hash = 0;
  for (let i = 0; i < fingerprint.length; i++) {
    const char = fingerprint.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash &= hash; // Convert to 32-bit integer
  }

  return Math.abs(hash).toString(36);
}

/**
 * Get client IP address
 */
async function getClientIP(): Promise<string> {
  try {
    const response = await fetch('https://api.ipify.org?format=json');
    const data = await response.json();
    return data.ip || '127.0.0.1';
  } catch {
    return '127.0.0.1';
  }
}

/**
 * Get user location
 */
async function getLocation(): Promise<string | undefined> {
  try {
    const response = await fetch('https://ipapi.co/json/');
    const data = await response.json();
    return `${data.city}, ${data.country_name}`;
  } catch {
    return;
  }
}

// =====================================================
// EXPORT DEFAULT
// =====================================================

export default useSession;
