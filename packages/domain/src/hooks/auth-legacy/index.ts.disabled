'use client';

import { useSession as useSupabaseSession } from '@neonpro/utils';
import React, {
  createContext,
  type ReactNode,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState,
} from 'react';
import { useDeviceManagement } from './useDeviceManagement';
import { dispatchCustomActivity, useSessionActivity } from './useSessionActivity';

// =====================================================
// TYPES
// =====================================================

export type SessionState = {
  isAuthenticated: boolean;
  user: any | null;
  loading: boolean;
  error: string | null;
  lastActivity: Date | null;
  sessionDuration: number;
  deviceInfo: any | null;
};

export type SecurityMonitoringData = {
  suspiciousActivity: boolean;
  riskLevel: 'low' | 'medium' | 'high';
  lastRiskAssessment: Date | null;
  failedAttempts: number;
};

// =====================================================
// SESSION MANAGEMENT HOOK
// =====================================================

export function useSession() {
  const { user, session, loading, error, signOut } = useSupabaseSession();
  const [lastActivity, setLastActivity] = useState<Date | null>(null);
  const [sessionDuration, setSessionDuration] = useState(0);
  const sessionStartRef = useRef<Date | null>(null);

  const isAuthenticated = Boolean(user) && Boolean(session);

  useEffect(() => {
    if (isAuthenticated && !sessionStartRef.current) {
      sessionStartRef.current = new Date();
    } else if (!isAuthenticated) {
      sessionStartRef.current = null;
    }
  }, [isAuthenticated]);

  useEffect(() => {
    if (!sessionStartRef.current) {
      return;
    }

    const interval = setInterval(() => {
      const now = new Date();
      const duration = now.getTime() - sessionStartRef.current?.getTime();
      setSessionDuration(duration);
    }, 1000);

    return () => clearInterval(interval);
  }, []);

  const updateActivity = useCallback(async (activityType: string, metadata?: any) => {
    setLastActivity(new Date());
    dispatchCustomActivity(activityType, metadata);
  }, []);

  return {
    user,
    session,
    isAuthenticated,
    loading,
    error,
    lastActivity,
    sessionDuration,
    updateActivity,
    signOut,
  };
}

// =====================================================
// SESSION TIMEOUT HOOK
// =====================================================

export function useSessionTimeout(timeoutMinutes = 30) {
  const { isAuthenticated, signOut, lastActivity } = useSession();
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);

  const resetTimeout = useCallback(() => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }

    if (isAuthenticated) {
      timeoutRef.current = setTimeout(
        () => {
          signOut();
        },
        timeoutMinutes * 60 * 1000
      );
    }
  }, [isAuthenticated, signOut, timeoutMinutes]);

  useEffect(() => {
    resetTimeout();
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, [resetTimeout]);

  return { resetTimeout };
}

// =====================================================
// SECURITY MONITORING HOOK
// =====================================================

export function useSecurityMonitoring() {
  const [securityData, setSecurityData] = useState<SecurityMonitoringData>({
    suspiciousActivity: false,
    riskLevel: 'low',
    lastRiskAssessment: null,
    failedAttempts: 0,
  });

  const updateRiskLevel = useCallback((level: 'low' | 'medium' | 'high') => {
    setSecurityData((prev) => ({
      ...prev,
      riskLevel: level,
      lastRiskAssessment: new Date(),
    }));
  }, []);

  const reportFailedAttempt = useCallback(() => {
    setSecurityData((prev) => ({
      ...prev,
      failedAttempts: prev.failedAttempts + 1,
      suspiciousActivity: prev.failedAttempts + 1 >= 3,
      riskLevel:
        prev.failedAttempts + 1 >= 5 ? 'high' : prev.failedAttempts + 1 >= 3 ? 'medium' : 'low',
    }));
  }, []);

  const clearSecurityData = useCallback(() => {
    setSecurityData({
      suspiciousActivity: false,
      riskLevel: 'low',
      lastRiskAssessment: new Date(),
      failedAttempts: 0,
    });
  }, []);

  return {
    securityData,
    updateRiskLevel,
    reportFailedAttempt,
    clearSecurityData,
  };
}

// =====================================================
// SESSION STATISTICS HOOK
// =====================================================

export function useSessionStatistics() {
  const { sessionDuration, isAuthenticated } = useSession();
  const { getActivityHistory } = useSessionActivity();
  const { deviceInfo } = useDeviceManagement();

  const sessionStats = useMemo(() => {
    if (!isAuthenticated) {
      return null;
    }

    const activities = getActivityHistory();
    const _now = new Date();

    return {
      duration: sessionDuration,
      activitiesCount: activities.length,
      averageActivityInterval: activities.length > 1 ? sessionDuration / activities.length : 0,
      deviceType: deviceInfo?.type || 'unknown',
      browser: deviceInfo?.browser || 'unknown',
    };
  }, [sessionDuration, isAuthenticated, getActivityHistory, deviceInfo]);

  return {
    sessionStats,
    insights: {
      isActiveSession: sessionStats ? sessionStats.activitiesCount > 10 : false,
      estimatedEngagement: sessionStats
        ? Math.min(
            100,
            Math.round((sessionStats.activitiesCount / (sessionStats.duration / 60_000)) * 10)
          )
        : 0,
      activitiesPerHour:
        sessionStats && sessionStats.duration > 0
          ? Math.round((sessionStats.activitiesCount / sessionStats.duration) * (1000 * 60 * 60))
          : 0,
    },
  };
}

// =====================================================
// COMPLETE SESSION MANAGEMENT HOOK
// =====================================================

export function useCompleteSessionManagement(_userId?: string) {
  const session = useSession();
  const sessionActivity = useSessionActivity();
  const deviceManagement = useDeviceManagement();
  const sessionTimeout = useSessionTimeout();
  const securityMonitoring = useSecurityMonitoring();
  const sessionStatistics = useSessionStatistics();

  return {
    ...session,
    ...sessionActivity,
    ...deviceManagement,
    ...sessionTimeout,
    ...securityMonitoring,
    ...sessionStatistics,
  };
}

// =====================================================
// CONTEXT PROVIDERS
// =====================================================

const SessionContext = createContext<ReturnType<typeof useCompleteSessionManagement> | null>(null);

export function SessionProvider({ children, userId }: { children: ReactNode; userId?: string }) {
  const sessionManagement = useCompleteSessionManagement(userId);

  return React.createElement(SessionContext.Provider, { value: sessionManagement }, children);
}

export function useSessionContext() {
  const context = useContext(SessionContext);
  if (!context) {
    throw new Error('useSessionContext must be used within a SessionProvider');
  }
  return context;
}

// =====================================================
// EXPORTS
// =====================================================

export default {
  useSession,
  useSessionActivity,
  useDeviceManagement,
  useCompleteSessionManagement,
  useSessionTimeout,
  useSecurityMonitoring,
  useSessionStatistics,
  SessionProvider,
  useSessionContext,
};
