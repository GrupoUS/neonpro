// =====================================================
// useSessionActivity Hook - Automatic Activity Tracking
// Story 1.4: Session Management & Security
// =====================================================

import { usePathname, useRouter } from '../placeholders/next-navigation';
import React, { useCallback, useEffect, useRef } from 'react';
import { useSession } from './useSession';

// =====================================================
// TYPES & INTERFACES
// =====================================================

export type ActivityTrackingOptions = {
  trackPageViews?: boolean;
  trackClicks?: boolean;
  trackFormSubmissions?: boolean;
  trackScrolling?: boolean;
  trackIdleTime?: boolean;
  idleThresholdMs?: number;
  debounceMs?: number;
  excludePaths?: string[];
  customActivities?: string[];
};

export type ActivityEvent = {
  type: string;
  timestamp: Date;
  metadata?: Record<string, any>;
};

export type UseSessionActivityReturn = {
  trackActivity: (activityType: string, metadata?: any) => Promise<void>;
  getActivityHistory: () => ActivityEvent[];
  isIdle: boolean;
  lastActivity: Date | null;
  clearActivityHistory: () => void;
};

// =====================================================
// DEFAULT OPTIONS
// =====================================================

const DEFAULT_OPTIONS: Required<ActivityTrackingOptions> = {
  trackPageViews: true,
  trackClicks: true,
  trackFormSubmissions: true,
  trackScrolling: false,
  trackIdleTime: true,
  idleThresholdMs: 5 * 60 * 1000, // 5 minutes
  debounceMs: 1000, // 1 second
  excludePaths: ['/api', '/health', '/favicon.ico'],
  customActivities: [],
};

// =====================================================
// MAIN HOOK
// =====================================================

export function useSessionActivity(
  options: ActivityTrackingOptions = {}
): UseSessionActivityReturn {
  const config = { ...DEFAULT_OPTIONS, ...options };
  const { updateActivity, isAuthenticated } = useSession();
  const _router = useRouter();
  const pathname = usePathname();

  // State refs
  const activityHistoryRef = useRef<ActivityEvent[]>([]);
  const lastActivityRef = useRef<Date | null>(null);
  const isIdleRef = useRef(false);
  const idleTimerRef = useRef<NodeJS.Timeout | null>(null);
  const debounceTimerRef = useRef<NodeJS.Timeout | null>(null);
  const scrollDebounceRef = useRef<NodeJS.Timeout | null>(null);

  // =====================================================
  // ACTIVITY TRACKING FUNCTIONS
  // =====================================================

  const trackActivity = useCallback(
    async (activityType: string, metadata?: any) => {
      if (!isAuthenticated) {
        return;
      }

      try {
        const now = new Date();

        // Add to local history
        const activityEvent: ActivityEvent = {
          type: activityType,
          timestamp: now,
          metadata,
        };

        activityHistoryRef.current.push(activityEvent);

        // Keep only last 100 activities
        if (activityHistoryRef.current.length > 100) {
          activityHistoryRef.current = activityHistoryRef.current.slice(-100);
        }

        // Update last activity
        lastActivityRef.current = now;

        // Reset idle state
        if (isIdleRef.current) {
          isIdleRef.current = false;
          await updateActivity('idle_end', {
            duration: Date.now() - (lastActivityRef.current?.getTime() || 0),
          });
        }

        // Reset idle timer
        resetIdleTimer();

        // Send to session manager
        await updateActivity(activityType, {
          ...metadata,
          pathname,
          timestamp: now.toISOString(),
          userAgent: navigator.userAgent,
        });
      } catch (_error) {}
    },
    [
      isAuthenticated,
      updateActivity,
      pathname, // Reset idle timer
      resetIdleTimer,
    ]
  );

  const debouncedTrackActivity = useCallback(
    (activityType: string, metadata?: any) => {
      if (debounceTimerRef.current) {
        clearTimeout(debounceTimerRef.current);
      }

      debounceTimerRef.current = setTimeout(() => {
        trackActivity(activityType, metadata);
      }, config.debounceMs);
    },
    [trackActivity, config.debounceMs]
  );

  // =====================================================
  // IDLE DETECTION
  // =====================================================

  const resetIdleTimer = useCallback(() => {
    if (!config.trackIdleTime) {
      return;
    }

    if (idleTimerRef.current) {
      clearTimeout(idleTimerRef.current);
    }

    idleTimerRef.current = setTimeout(async () => {
      if (!isIdleRef.current) {
        isIdleRef.current = true;
        await trackActivity('idle_start', {
          lastActivity: lastActivityRef.current?.toISOString(),
        });
      }
    }, config.idleThresholdMs);
  }, [config.trackIdleTime, config.idleThresholdMs, trackActivity]);

  // =====================================================
  // EVENT HANDLERS
  // =====================================================

  const handlePageView = useCallback(() => {
    if (!config.trackPageViews) {
      return;
    }
    if (config.excludePaths.some((path) => pathname.startsWith(path))) {
      return;
    }

    trackActivity('page_view', {
      path: pathname,
      referrer: document.referrer,
      title: document.title,
    });
  }, [config.trackPageViews, config.excludePaths, pathname, trackActivity]);

  const handleClick = useCallback(
    (event: MouseEvent) => {
      if (!config.trackClicks) {
        return;
      }

      const target = event.target as HTMLElement;
      const tagName = target.tagName.toLowerCase();
      const className = target.className;
      const id = target.id;
      const text = target.textContent?.slice(0, 100) || '';

      debouncedTrackActivity('click', {
        tagName,
        className,
        id,
        text,
        x: event.clientX,
        y: event.clientY,
      });
    },
    [config.trackClicks, debouncedTrackActivity]
  );

  const handleFormSubmit = useCallback(
    (event: Event) => {
      if (!config.trackFormSubmissions) {
        return;
      }

      const form = event.target as HTMLFormElement;
      const formData = new FormData(form);
      const fields = Array.from(formData.keys());

      trackActivity('form_submit', {
        formId: form.id,
        formAction: form.action,
        formMethod: form.method,
        fieldCount: fields.length,
        fields: fields.filter((field) => !field.toLowerCase().includes('password')),
      });
    },
    [config.trackFormSubmissions, trackActivity]
  );

  const handleScroll = useCallback(() => {
    if (!config.trackScrolling) {
      return;
    }

    if (scrollDebounceRef.current) {
      clearTimeout(scrollDebounceRef.current);
    }

    scrollDebounceRef.current = setTimeout(() => {
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      const scrollHeight = document.documentElement.scrollHeight;
      const clientHeight = document.documentElement.clientHeight;
      const scrollPercentage = Math.round((scrollTop / (scrollHeight - clientHeight)) * 100);

      debouncedTrackActivity('scroll', {
        scrollTop,
        scrollPercentage,
        scrollHeight,
        clientHeight,
      });
    }, 500);
  }, [config.trackScrolling, debouncedTrackActivity]);

  const handleKeyPress = useCallback(
    (event: KeyboardEvent) => {
      // Track specific key combinations
      if (event.ctrlKey || event.metaKey) {
        debouncedTrackActivity('keyboard_shortcut', {
          key: event.key,
          ctrlKey: event.ctrlKey,
          metaKey: event.metaKey,
          shiftKey: event.shiftKey,
          altKey: event.altKey,
        });
      }
    },
    [debouncedTrackActivity]
  );

  const handleVisibilityChange = useCallback(() => {
    if (document.hidden) {
      trackActivity('page_hidden', {
        timestamp: new Date().toISOString(),
      });
    } else {
      trackActivity('page_visible', {
        timestamp: new Date().toISOString(),
      });
    }
  }, [trackActivity]);

  const handleBeforeUnload = useCallback(() => {
    trackActivity('page_unload', {
      timestamp: new Date().toISOString(),
      sessionDuration: lastActivityRef.current ? Date.now() - lastActivityRef.current.getTime() : 0,
    });
  }, [trackActivity]);

  // =====================================================
  // EFFECTS
  // =====================================================

  // Track page view on pathname change
  useEffect(() => {
    if (isAuthenticated) {
      handlePageView();
    }
  }, [isAuthenticated, handlePageView]);

  // Set up event listeners
  useEffect(() => {
    if (!isAuthenticated) {
      return;
    }

    // Add event listeners
    if (config.trackClicks) {
      document.addEventListener('click', handleClick, { passive: true });
    }

    if (config.trackFormSubmissions) {
      document.addEventListener('submit', handleFormSubmit);
    }

    if (config.trackScrolling) {
      window.addEventListener('scroll', handleScroll, { passive: true });
    }

    document.addEventListener('keydown', handleKeyPress);
    document.addEventListener('visibilitychange', handleVisibilityChange);
    window.addEventListener('beforeunload', handleBeforeUnload);

    // Mouse movement for idle detection
    const handleMouseMove = () => resetIdleTimer();
    document.addEventListener('mousemove', handleMouseMove, { passive: true });

    // Initial idle timer
    resetIdleTimer();

    // Cleanup
    return () => {
      document.removeEventListener('click', handleClick);
      document.removeEventListener('submit', handleFormSubmit);
      window.removeEventListener('scroll', handleScroll);
      document.removeEventListener('keydown', handleKeyPress);
      document.removeEventListener('visibilitychange', handleVisibilityChange);
      window.removeEventListener('beforeunload', handleBeforeUnload);
      document.removeEventListener('mousemove', handleMouseMove);

      if (idleTimerRef.current) {
        clearTimeout(idleTimerRef.current);
      }
      if (debounceTimerRef.current) {
        clearTimeout(debounceTimerRef.current);
      }
      if (scrollDebounceRef.current) {
        clearTimeout(scrollDebounceRef.current);
      }
    };
  }, [
    isAuthenticated,
    config,
    handleClick,
    handleFormSubmit,
    handleScroll,
    handleKeyPress,
    handleVisibilityChange,
    handleBeforeUnload,
    resetIdleTimer,
  ]);

  // =====================================================
  // UTILITY FUNCTIONS
  // =====================================================

  const getActivityHistory = useCallback((): ActivityEvent[] => {
    return [...activityHistoryRef.current];
  }, []);

  const clearActivityHistory = useCallback(() => {
    activityHistoryRef.current = [];
  }, []);

  // =====================================================
  // CUSTOM ACTIVITY TRACKING
  // =====================================================

  // Track custom activities defined in options
  useEffect(() => {
    if (!isAuthenticated || config.customActivities.length === 0) {
      return;
    }

    const handleCustomActivity = (event: CustomEvent) => {
      if (config.customActivities.includes(event.type)) {
        trackActivity(event.type, event.detail);
      }
    };

    // Listen for custom events
    config.customActivities.forEach((activityType) => {
      document.addEventListener(activityType, handleCustomActivity as EventListener);
    });

    return () => {
      config.customActivities.forEach((activityType) => {
        document.removeEventListener(activityType, handleCustomActivity as EventListener);
      });
    };
  }, [isAuthenticated, config.customActivities, trackActivity]);

  // =====================================================
  // RETURN HOOK INTERFACE
  // =====================================================

  return {
    trackActivity,
    getActivityHistory,
    isIdle: isIdleRef.current,
    lastActivity: lastActivityRef.current,
    clearActivityHistory,
  };
}

// =====================================================
// UTILITY FUNCTIONS FOR CUSTOM EVENTS
// =====================================================

/**
 * Dispatch a custom activity event
 */
export function dispatchCustomActivity(activityType: string, metadata?: any) {
  const event = new CustomEvent(activityType, {
    detail: metadata,
  });
  document.dispatchEvent(event);
}

/**
 * Higher-order component to automatically track component interactions
 */
export function withActivityTracking<T extends Record<string, any>>(
  Component: React.ComponentType<T>,
  activityType: string
) {
  return function TrackedComponent(props: T) {
    const { trackActivity } = useSessionActivity();

    useEffect(() => {
      trackActivity(`component_mount_${activityType}`, {
        componentName: Component.displayName || Component.name,
      });

      return () => {
        trackActivity(`component_unmount_${activityType}`, {
          componentName: Component.displayName || Component.name,
        });
      };
    }, [trackActivity, Component.displayName, Component.name, activityType]);

    return React.createElement(Component, props);
  };
}

/**
 * Hook for tracking specific business actions
 */
export function useBusinessActivityTracking() {
  const { trackActivity } = useSessionActivity();

  return {
    trackPurchase: (metadata: unknown) => trackActivity('purchase', metadata),
    trackSearch: (query: string, results: number) => trackActivity('search', { query, results }),
    trackDownload: (filename: string, fileType: string) =>
      trackActivity('download', { filename, fileType }),
    trackShare: (content: string, platform: string) =>
      trackActivity('share', { content, platform }),
    trackError: (error: string, context: string) => trackActivity('error', { error, context }),
    trackFeatureUsage: (feature: string, metadata?: any) =>
      trackActivity('feature_usage', { feature, ...metadata }),
  };
}

// =====================================================
// EXPORT DEFAULT
// =====================================================

export default useSessionActivity;
