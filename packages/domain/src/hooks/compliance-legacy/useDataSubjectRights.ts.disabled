'use client';

import { useCallback, useEffect, useState } from 'react';
import { useToast } from '../placeholders/sonner'; const useToast = () => ({ toast });
import { LGPDComplianceManager } // Missing module - placeholder needed
import type {
  DataSubjectRequest,
  DataSubjectRequestFilters,
  PaginatedResponse,
} // Missing types - placeholder needed

type UseDataSubjectRightsReturn = {
  // Data
  requests: DataSubjectRequest[];
  totalCount: number;
  currentPage: number;
  statistics: {
    pending: number;
    inProgress: number;
    completed: number;
    rejected: number;
  };

  // Loading states
  isLoading: boolean;
  isProcessing: boolean;

  // Filters
  filters: DataSubjectRequestFilters;
  setFilters: (filters: DataSubjectRequestFilters) => void;

  // Actions
  loadRequests: () => Promise<void>;
  processRequest: (
    requestId: string,
    action: 'approve' | 'reject',
    notes?: string
  ) => Promise<void>;
  updateRequestStatus: (
    requestId: string,
    status: DataSubjectRequest['status'],
    notes?: string
  ) => Promise<void>;
  exportRequests: () => Promise<void>;

  // Pagination
  goToPage: (page: number) => void;

  // Error handling
  error: string | null;
};

export function useDataSubjectRights(): UseDataSubjectRightsReturn {
  const [requests, setRequests] = useState<DataSubjectRequest[]>([]);
  const [totalCount, setTotalCount] = useState(0);
  const [currentPage, setCurrentPage] = useState(1);
  const [statistics, setStatistics] = useState({
    pending: 0,
    inProgress: 0,
    completed: 0,
    rejected: 0,
  });
  const [isLoading, setIsLoading] = useState(true);
  const [isProcessing, setIsProcessing] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const [filters, setFilters] = useState<DataSubjectRequestFilters>({
    limit: 20,
    offset: 0,
    sortBy: 'created_at',
    sortOrder: 'desc',
  });

  const { toast } = useToast();
  const complianceManager = new LGPDComplianceManager();

  const loadRequests = useCallback(async () => {
    try {
      setError(null);
      const response: PaginatedResponse<DataSubjectRequest> =
        await complianceManager.getDataSubjectRequests({
          ...filters,
          offset: (currentPage - 1) * (filters.limit || 20),
        });

      setRequests(response.data);
      setTotalCount(response.total);

      // Calculate statistics
      const stats = response.data.reduce(
        (acc, request) => {
          acc[request.status as keyof typeof acc]++;
          return acc;
        },
        { pending: 0, inProgress: 0, completed: 0, rejected: 0 }
      );
      setStatistics(stats);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao carregar solicitações';
      setError(errorMessage);
      toast({
        title: 'Erro',
        description: errorMessage,
        variant: 'destructive',
      });
    }
  }, [filters, currentPage, complianceManager, toast]);

  const processRequest = useCallback(
    async (requestId: string, action: 'approve' | 'reject', notes?: string) => {
      setIsProcessing(true);
      try {
        setError(null);

        const newStatus = action === 'approve' ? 'completed' : 'rejected';
        const updateData = {
          status: newStatus as DataSubjectRequest['status'],
          processed_at: new Date().toISOString(),
          notes: notes || '',
        };

        await complianceManager.updateDataSubjectRequest(requestId, updateData);

        // Update local state
        setRequests((prev) =>
          prev.map((request) =>
            request.id === requestId
              ? {
                  ...request,
                  ...updateData,
                  updated_at: new Date().toISOString(),
                }
              : request
          )
        );

        // Update statistics
        setStatistics((prev) => {
          const request = requests.find((r) => r.id === requestId);
          if (!request) {
            return prev;
          }

          const newStats = { ...prev };
          newStats[request.status as keyof typeof newStats]--;
          newStats[newStatus as keyof typeof newStats]++;
          return newStats;
        });

        toast({
          title: 'Solicitação processada',
          description: `Solicitação foi ${action === 'approve' ? 'aprovada' : 'rejeitada'} com sucesso.`,
        });
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Erro ao processar solicitação';
        setError(errorMessage);
        toast({
          title: 'Erro',
          description: errorMessage,
          variant: 'destructive',
        });
      } finally {
        setIsProcessing(false);
      }
    },
    [complianceManager, requests, toast]
  );

  const updateRequestStatus = useCallback(
    async (requestId: string, status: DataSubjectRequest['status'], notes?: string) => {
      setIsProcessing(true);
      try {
        setError(null);

        const updateData = {
          status,
          updated_at: new Date().toISOString(),
          ...(notes && { notes }),
          ...(status === 'completed' && {
            processed_at: new Date().toISOString(),
          }),
        };

        await complianceManager.updateDataSubjectRequest(requestId, updateData);

        // Update local state
        setRequests((prev) =>
          prev.map((request) =>
            request.id === requestId ? { ...request, ...updateData } : request
          )
        );

        // Update statistics
        setStatistics((prev) => {
          const request = requests.find((r) => r.id === requestId);
          if (!request) {
            return prev;
          }

          const newStats = { ...prev };
          newStats[request.status as keyof typeof newStats]--;
          newStats[status as keyof typeof newStats]++;
          return newStats;
        });

        toast({
          title: 'Status atualizado',
          description: 'Status da solicitação foi atualizado com sucesso.',
        });
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Erro ao atualizar status';
        setError(errorMessage);
        toast({
          title: 'Erro',
          description: errorMessage,
          variant: 'destructive',
        });
      } finally {
        setIsProcessing(false);
      }
    },
    [complianceManager, requests, toast]
  );

  const exportRequests = useCallback(async () => {
    try {
      setError(null);

      // Create CSV content
      const csvHeaders = [
        'ID',
        'Tipo',
        'Usuário',
        'Email',
        'Status',
        'Data de Criação',
        'Data de Processamento',
        'Prazo',
        'Descrição',
        'Observações',
      ];

      const csvRows = requests.map((request) => [
        request.id,
        request.request_type,
        request.user_id || '',
        request.email || '',
        request.status,
        request.created_at,
        request.processed_at || '',
        request.deadline || '',
        request.description || '',
        request.notes || '',
      ]);

      const csvContent = [csvHeaders, ...csvRows]
        .map((row) => row.map((cell) => `"${cell}"`).join(','))
        .join('\n');

      // Create and download file
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', `lgpd-requests-${new Date().toISOString().split('T')[0]}.csv`);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);

      toast({
        title: 'Exportação concluída',
        description: 'Solicitações exportadas com sucesso.',
      });
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao exportar solicitações';
      setError(errorMessage);
      toast({
        title: 'Erro na exportação',
        description: errorMessage,
        variant: 'destructive',
      });
    }
  }, [requests, toast]);

  const goToPage = useCallback((page: number) => {
    setCurrentPage(page);
  }, []);

  // Load data on mount and when filters change
  useEffect(() => {
    const loadData = async () => {
      setIsLoading(true);
      await loadRequests();
      setIsLoading(false);
    };

    loadData();
  }, [loadRequests]);

  return {
    // Data
    requests,
    totalCount,
    currentPage,
    statistics,

    // Loading states
    isLoading,
    isProcessing,

    // Filters
    filters,
    setFilters,

    // Actions
    loadRequests,
    processRequest,
    updateRequestStatus,
    exportRequests,

    // Pagination
    goToPage,

    // Error handling
    error,
  };
}
