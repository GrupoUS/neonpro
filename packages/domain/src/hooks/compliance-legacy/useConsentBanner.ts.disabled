'use client';

import { useCallback, useEffect, useState } from 'react';
import { useToast } from '../placeholders/sonner'; const useToast = () => ({ toast });
import { LGPDComplianceManager } // Missing module - placeholder needed
import type { ConsentPurpose, ConsentRecord } // Missing types - placeholder needed

type ConsentPreferences = {
  [purposeId: string]: boolean;
};

type UseConsentBannerReturn = {
  // Data
  purposes: ConsentPurpose[];
  consentHistory: ConsentRecord[];
  preferences: ConsentPreferences;

  // Banner state
  showBanner: boolean;
  showPreferences: boolean;

  // Loading states
  isLoading: boolean;
  isSaving: boolean;

  // Actions
  acceptAll: () => Promise<void>;
  rejectAll: () => Promise<void>;
  savePreferences: (preferences: ConsentPreferences) => Promise<void>;
  updatePreference: (purposeId: string, granted: boolean) => void;

  // Banner control
  showBannerDialog: () => void;
  hideBanner: () => void;
  showPreferencesDialog: () => void;
  hidePreferences: () => void;

  // Utility
  loadConsentHistory: () => Promise<void>;
  hasConsent: (purposeId: string) => boolean;

  // Error handling
  error: string | null;
};

const CONSENT_STORAGE_KEY = 'lgpd_consent_preferences';
const BANNER_SHOWN_KEY = 'lgpd_banner_shown';

export function useConsentBanner(): UseConsentBannerReturn {
  const [purposes, setPurposes] = useState<ConsentPurpose[]>([]);
  const [consentHistory, setConsentHistory] = useState<ConsentRecord[]>([]);
  const [preferences, setPreferences] = useState<ConsentPreferences>({});
  const [showBanner, setShowBanner] = useState(false);
  const [showPreferences, setShowPreferences] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [isSaving, setIsSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const { toast } = useToast();
  const complianceManager = new LGPDComplianceManager();

  // Load stored preferences from localStorage
  const loadStoredPreferences = useCallback(() => {
    try {
      const stored = localStorage.getItem(CONSENT_STORAGE_KEY);
      if (stored) {
        const parsedPreferences = JSON.parse(stored);
        setPreferences(parsedPreferences);
        return parsedPreferences;
      }
    } catch (_err) {}
    return {};
  }, []);

  // Save preferences to localStorage
  const saveToStorage = useCallback((prefs: ConsentPreferences) => {
    try {
      localStorage.setItem(CONSENT_STORAGE_KEY, JSON.stringify(prefs));
      localStorage.setItem(BANNER_SHOWN_KEY, 'true');
    } catch (_err) {}
  }, []);

  // Check if banner should be shown
  const shouldShowBanner = useCallback(() => {
    try {
      const bannerShown = localStorage.getItem(BANNER_SHOWN_KEY);
      const hasStoredPreferences = localStorage.getItem(CONSENT_STORAGE_KEY);
      return !(bannerShown || hasStoredPreferences);
    } catch (_err) {
      return true; // Show banner if we can't check localStorage
    }
  }, []);

  // Load consent purposes
  const loadPurposes = useCallback(async () => {
    try {
      setError(null);
      const response = await complianceManager.getConsentPurposes();
      setPurposes(response.data);

      // Initialize preferences for new purposes
      const storedPrefs = loadStoredPreferences();
      const newPrefs = { ...storedPrefs };

      response.data.forEach((purpose) => {
        if (!(purpose.id in newPrefs)) {
          // Default to false for optional purposes, true for essential
          newPrefs[purpose.id] = purpose.required;
        }
      });

      setPreferences(newPrefs);

      // Show banner if needed
      if (shouldShowBanner()) {
        setShowBanner(true);
      }
    } catch (err) {
      const errorMessage =
        err instanceof Error ? err.message : 'Erro ao carregar finalidades de consentimento';
      setError(errorMessage);
    }
  }, [complianceManager, loadStoredPreferences, shouldShowBanner]);

  // Load consent history
  const loadConsentHistory = useCallback(async () => {
    try {
      setError(null);
      const response = await complianceManager.getConsentRecords({
        limit: 50,
        sortBy: 'created_at',
        sortOrder: 'desc',
      });
      setConsentHistory(response.data);
    } catch (err) {
      const errorMessage =
        err instanceof Error ? err.message : 'Erro ao carregar histórico de consentimentos';
      setError(errorMessage);
    }
  }, [complianceManager]);

  // Accept all consents
  const acceptAll = useCallback(async () => {
    try {
      setIsSaving(true);
      setError(null);

      const allAccepted: ConsentPreferences = {};
      purposes.forEach((purpose) => {
        allAccepted[purpose.id] = true;
      });

      // Save to backend
      await Promise.all(
        purposes.map((purpose) =>
          complianceManager.recordConsent({
            purpose_id: purpose.id,
            granted: true,
            user_id: 'anonymous', // Will be replaced with actual user ID when available
            ip_address: '', // Will be filled by backend
            user_agent: navigator.userAgent,
          })
        )
      );

      setPreferences(allAccepted);
      saveToStorage(allAccepted);
      setShowBanner(false);

      toast({
        title: 'Consentimentos salvos',
        description: 'Todos os consentimentos foram aceitos com sucesso.',
      });
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao salvar consentimentos';
      setError(errorMessage);
      toast({
        title: 'Erro',
        description: errorMessage,
        variant: 'destructive',
      });
    } finally {
      setIsSaving(false);
    }
  }, [purposes, complianceManager, saveToStorage, toast]);

  // Reject all optional consents
  const rejectAll = useCallback(async () => {
    try {
      setIsSaving(true);
      setError(null);

      const onlyRequired: ConsentPreferences = {};
      purposes.forEach((purpose) => {
        onlyRequired[purpose.id] = purpose.required;
      });

      // Save to backend
      await Promise.all(
        purposes.map((purpose) =>
          complianceManager.recordConsent({
            purpose_id: purpose.id,
            granted: purpose.required,
            user_id: 'anonymous', // Will be replaced with actual user ID when available
            ip_address: '', // Will be filled by backend
            user_agent: navigator.userAgent,
          })
        )
      );

      setPreferences(onlyRequired);
      saveToStorage(onlyRequired);
      setShowBanner(false);

      toast({
        title: 'Consentimentos salvos',
        description: 'Apenas consentimentos essenciais foram mantidos.',
      });
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Erro ao salvar consentimentos';
      setError(errorMessage);
      toast({
        title: 'Erro',
        description: errorMessage,
        variant: 'destructive',
      });
    } finally {
      setIsSaving(false);
    }
  }, [purposes, complianceManager, saveToStorage, toast]);

  // Save custom preferences
  const savePreferences = useCallback(
    async (newPreferences: ConsentPreferences) => {
      try {
        setIsSaving(true);
        setError(null);

        // Ensure required purposes are always true
        const validatedPreferences = { ...newPreferences };
        purposes.forEach((purpose) => {
          if (purpose.required) {
            validatedPreferences[purpose.id] = true;
          }
        });

        // Save to backend
        await Promise.all(
          Object.entries(validatedPreferences).map(([purposeId, granted]) =>
            complianceManager.recordConsent({
              purpose_id: purposeId,
              granted,
              user_id: 'anonymous', // Will be replaced with actual user ID when available
              ip_address: '', // Will be filled by backend
              user_agent: navigator.userAgent,
            })
          )
        );

        setPreferences(validatedPreferences);
        saveToStorage(validatedPreferences);
        setShowBanner(false);
        setShowPreferences(false);

        toast({
          title: 'Preferências salvas',
          description: 'Suas preferências de consentimento foram atualizadas.',
        });
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Erro ao salvar preferências';
        setError(errorMessage);
        toast({
          title: 'Erro',
          description: errorMessage,
          variant: 'destructive',
        });
      } finally {
        setIsSaving(false);
      }
    },
    [purposes, complianceManager, saveToStorage, toast]
  );

  // Update single preference
  const updatePreference = useCallback(
    (purposeId: string, granted: boolean) => {
      const purpose = purposes.find((p) => p.id === purposeId);
      if (purpose?.required && !granted) {
        toast({
          title: 'Consentimento obrigatório',
          description: 'Este consentimento é obrigatório e não pode ser desabilitado.',
          variant: 'destructive',
        });
        return;
      }

      setPreferences((prev) => ({
        ...prev,
        [purposeId]: granted,
      }));
    },
    [purposes, toast]
  );

  // Banner control functions
  const showBannerDialog = useCallback(() => setShowBanner(true), []);
  const hideBanner = useCallback(() => setShowBanner(false), []);
  const showPreferencesDialog = useCallback(() => setShowPreferences(true), []);
  const hidePreferences = useCallback(() => setShowPreferences(false), []);

  // Check if user has consent for a specific purpose
  const hasConsent = useCallback(
    (purposeId: string) => {
      return preferences[purposeId] === true;
    },
    [preferences]
  );

  // Load data on mount
  useEffect(() => {
    const loadData = async () => {
      setIsLoading(true);
      await Promise.all([loadPurposes(), loadConsentHistory()]);
      setIsLoading(false);
    };

    loadData();
  }, [loadPurposes, loadConsentHistory]);

  return {
    // Data
    purposes,
    consentHistory,
    preferences,

    // Banner state
    showBanner,
    showPreferences,

    // Loading states
    isLoading,
    isSaving,

    // Actions
    acceptAll,
    rejectAll,
    savePreferences,
    updatePreference,

    // Banner control
    showBannerDialog,
    hideBanner,
    showPreferencesDialog,
    hidePreferences,

    // Utility
    loadConsentHistory,
    hasConsent,

    // Error handling
    error,
  };
}
