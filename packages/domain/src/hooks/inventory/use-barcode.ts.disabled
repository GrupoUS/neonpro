/**
 * Barcode Scanner Hook
 * React hook for barcode/QR code scanning functionality
 * Story 6.1: Real-time Stock Tracking + Barcode/QR Integration
 */

'use client';

import { useCallback, useEffect, useRef, useState } from 'react';
import type {
  BarcodeFormat,
  BarcodeResult,
  ScanConfiguration,
  ScannerError,
  ScannerState,
} // Missing module - placeholder needed

type UseBarcodeOptions = {
  enableContinuousScanning?: boolean;
  onScanSuccess?: (result: BarcodeResult) => void;
  onScanError?: (error: ScannerError) => void;
  beepOnScan?: boolean;
  vibrationOnScan?: boolean;
  preferredDeviceId?: string;
  constraints?: MediaTrackConstraints;
};

type UseBarcodeReturn = {
  // Scanner state
  isScanning: boolean;
  isInitialized: boolean;
  hasPermission: boolean;
  error: ScannerError | null;

  // Scan result
  lastResult: BarcodeResult | null;
  scanHistory: BarcodeResult[];

  // Controls
  startScanning: (videoElement?: HTMLVideoElement) => Promise<boolean>;
  stopScanning: () => void;
  toggleScanning: () => void;
  switchCamera: () => Promise<void>;

  // Camera management
  availableCameras: MediaDeviceInfo[];
  currentCamera: MediaDeviceInfo | null;

  // Configuration
  configuration: ScanConfiguration;
  updateConfiguration: (config: Partial<ScanConfiguration>) => void;

  // Utils
  clearHistory: () => void;
  clearError: () => void;

  // Manual input fallback
  processManualInput: (barcodeValue: string) => void;
};

const DEFAULT_CONFIGURATION: ScanConfiguration = {
  enableContinuous: true,
  beepOnScan: true,
  vibrationOnScan: true,
  saveScanHistory: true,
  autoFocus: true,
  preferredCameraFacing: 'environment', // Back camera for mobile
  scanDelay: 500, // ms between scans
  maxHistorySize: 100,
};

export function useBarcode(options: UseBarcodeOptions = {}): UseBarcodeReturn {
  const {
    enableContinuousScanning = true,
    onScanSuccess,
    onScanError,
    beepOnScan = true,
    vibrationOnScan = true,
    preferredDeviceId,
  } = options;

  // State
  const [state, setState] = useState<ScannerState>({
    isScanning: false,
    isInitialized: false,
    hasPermission: false,
    error: null,
    lastResult: null,
    scanHistory: [],
    availableCameras: [],
    currentCamera: null,
  });

  const [configuration, setConfiguration] = useState<ScanConfiguration>({
    ...DEFAULT_CONFIGURATION,
    enableContinuous: enableContinuousScanning,
    beepOnScan,
    vibrationOnScan,
  });

  // Refs
  const videoElementRef = useRef<HTMLVideoElement | null>(null);
  const streamRef = useRef<MediaStream | null>(null);
  const scanTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const isProcessingScan = useRef(false);

  // Audio feedback
  const playBeep = useCallback(() => {
    if (!configuration.beepOnScan) {
      return;
    }

    try {
      const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();

      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);

      oscillator.frequency.value = 800; // Hz
      gainNode.gain.value = 0.1;

      oscillator.start();
      oscillator.stop(audioContext.currentTime + 0.2);
    } catch (_error) {}
  }, [configuration.beepOnScan]);

  // Vibration feedback
  const triggerVibration = useCallback(() => {
    if (!(configuration.vibrationOnScan && navigator.vibrate)) {
      return;
    }

    try {
      navigator.vibrate(200); // 200ms vibration
    } catch (_error) {}
  }, [configuration.vibrationOnScan]);

  // Get available cameras
  const getAvailableCameras = useCallback(async (): Promise<MediaDeviceInfo[]> => {
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const cameras = devices.filter((device) => device.kind === 'videoinput');

      setState((prev) => ({ ...prev, availableCameras: cameras }));
      return cameras;
    } catch (_error) {
      return [];
    }
  }, []);

  // Initialize scanner
  const initializeScanner = useCallback(async (): Promise<boolean> => {
    try {
      // Check for camera permission
      const permission = await navigator.permissions.query({
        name: 'camera' as PermissionName,
      });

      if (permission.state === 'denied') {
        setState((prev) => ({
          ...prev,
          error: {
            type: 'PERMISSION_DENIED',
            message: 'Camera permission denied',
            timestamp: new Date().toISOString(),
          },
        }));
        return false;
      }

      // Get available cameras
      await getAvailableCameras();

      setState((prev) => ({
        ...prev,
        isInitialized: true,
        hasPermission: permission.state === 'granted' || permission.state === 'prompt',
        error: null,
      }));

      return true;
    } catch (error) {
      setState((prev) => ({
        ...prev,
        error: {
          type: 'INITIALIZATION_ERROR',
          message: error instanceof Error ? error.message : 'Failed to initialize scanner',
          timestamp: new Date().toISOString(),
        },
      }));
      return false;
    }
  }, [getAvailableCameras]);

  // Process scan result
  const processScanResult = useCallback(
    (data: string, format: BarcodeFormat = 'unknown') => {
      if (isProcessingScan.current) {
        return;
      }
      isProcessingScan.current = true;

      const scanResult: BarcodeResult = {
        data,
        format,
        timestamp: new Date().toISOString(),
        sessionId: crypto.randomUUID(),
      };

      setState((prev) => {
        const newHistory = configuration.saveScanHistory
          ? [scanResult, ...prev.scanHistory.slice(0, configuration.maxHistorySize - 1)]
          : prev.scanHistory;

        return {
          ...prev,
          lastResult: scanResult,
          scanHistory: newHistory,
          error: null,
        };
      });

      // Feedback
      playBeep();
      triggerVibration();

      // Callback
      if (onScanSuccess) {
        onScanSuccess(scanResult);
      }

      // Reset processing flag after delay
      setTimeout(() => {
        isProcessingScan.current = false;
      }, configuration.scanDelay);
    },
    [
      configuration.saveScanHistory,
      configuration.maxHistorySize,
      configuration.scanDelay,
      playBeep,
      triggerVibration,
      onScanSuccess,
    ]
  );

  // Handle scan error
  const _handleScanError = useCallback(
    (error: Error) => {
      const scanError: ScannerError = {
        type: 'SCAN_ERROR',
        message: error.message,
        timestamp: new Date().toISOString(),
      };

      setState((prev) => ({ ...prev, error: scanError }));

      if (onScanError) {
        onScanError(scanError);
      }
    },
    [onScanError]
  );

  // Start scanning
  const startScanning = useCallback(
    async (videoElement?: HTMLVideoElement): Promise<boolean> => {
      try {
        if (!state.isInitialized) {
          const initialized = await initializeScanner();
          if (!initialized) {
            return false;
          }
        }

        const video = videoElement || videoElementRef.current;
        if (!video) {
          setState((prev) => ({
            ...prev,
            error: {
              type: 'NO_VIDEO_ELEMENT',
              message: 'No video element provided',
              timestamp: new Date().toISOString(),
            },
          }));
          return false;
        }

        videoElementRef.current = video;

        // Select camera
        const cameras = await getAvailableCameras();
        let selectedCamera = cameras.find((camera) => camera.deviceId === preferredDeviceId);

        if (!selectedCamera && cameras.length > 0) {
          // Prefer back camera for mobile
          selectedCamera =
            cameras.find(
              (camera) =>
                camera.label.toLowerCase().includes('back') ||
                camera.label.toLowerCase().includes('environment')
            ) || cameras[0];
        }

        if (!selectedCamera) {
          setState((prev) => ({
            ...prev,
            error: {
              type: 'NO_CAMERA_AVAILABLE',
              message: 'No camera available',
              timestamp: new Date().toISOString(),
            },
          }));
          return false;
        }

        // Get media stream
        const constraints: MediaStreamConstraints = {
          video: {
            deviceId: selectedCamera.deviceId,
            facingMode: configuration.preferredCameraFacing,
            width: { ideal: 1280 },
            height: { ideal: 720 },
            ...options.constraints,
          },
        };

        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        streamRef.current = stream;
        video.srcObject = stream;

        setState((prev) => ({
          ...prev,
          currentCamera: selectedCamera!,
          isScanning: true,
          error: null,
        }));

        return true;
      } catch (error) {
        setState((prev) => ({
          ...prev,
          isScanning: false,
          error: {
            type: 'START_ERROR',
            message: error instanceof Error ? error.message : 'Failed to start scanning',
            timestamp: new Date().toISOString(),
          },
        }));
        return false;
      }
    },
    [
      state.isInitialized,
      initializeScanner,
      getAvailableCameras,
      preferredDeviceId,
      configuration.preferredCameraFacing,
      options.constraints,
    ]
  );

  // Stop scanning
  const stopScanning = useCallback(() => {
    try {
      if (streamRef.current) {
        streamRef.current.getTracks().forEach((track) => track.stop());
        streamRef.current = null;
      }

      if (videoElementRef.current) {
        videoElementRef.current.srcObject = null;
      }

      if (scanTimeoutRef.current) {
        clearTimeout(scanTimeoutRef.current);
        scanTimeoutRef.current = null;
      }

      setState((prev) => ({
        ...prev,
        isScanning: false,
      }));
    } catch (_error) {}
  }, []);

  // Toggle scanning
  const toggleScanning = useCallback(() => {
    if (state.isScanning) {
      stopScanning();
    } else {
      startScanning();
    }
  }, [state.isScanning, startScanning, stopScanning]);

  // Switch camera
  const switchCamera = useCallback(async () => {
    if (state.availableCameras.length <= 1) {
      return;
    }

    const currentIndex = state.availableCameras.findIndex(
      (camera: MediaDeviceInfo) => camera.deviceId === state.currentCamera?.deviceId
    );

    const nextIndex = (currentIndex + 1) % state.availableCameras.length;
    const nextCamera = state.availableCameras[nextIndex];

    if (state.isScanning) {
      stopScanning();
      // Small delay before starting with new camera
      setTimeout(() => {
        setState((prev) => ({ ...prev, currentCamera: nextCamera }));
        startScanning();
      }, 100);
    } else {
      setState((prev) => ({ ...prev, currentCamera: nextCamera }));
    }
  }, [state.availableCameras, state.currentCamera, state.isScanning, stopScanning, startScanning]);

  // Update configuration
  const updateConfiguration = useCallback((config: Partial<ScanConfiguration>) => {
    setConfiguration((prev) => ({ ...prev, ...config }));
  }, []);

  // Clear history
  const clearHistory = useCallback(() => {
    setState((prev) => ({ ...prev, scanHistory: [] }));
  }, []);

  // Clear error
  const clearError = useCallback(() => {
    setState((prev) => ({ ...prev, error: null }));
  }, []);

  // Manual input fallback
  const processManualInput = useCallback(
    (barcodeValue: string) => {
      if (barcodeValue.trim()) {
        processScanResult(barcodeValue.trim(), 'unknown');
      }
    },
    [processScanResult]
  );

  // Initialize on mount
  useEffect(() => {
    initializeScanner();

    return () => {
      stopScanning();
    };
  }, [initializeScanner, stopScanning]);

  return {
    isScanning: state.isScanning,
    isInitialized: state.isInitialized,
    hasPermission: state.hasPermission,
    error: state.error,
    lastResult: state.lastResult,
    scanHistory: state.scanHistory,
    startScanning,
    stopScanning,
    toggleScanning,
    switchCamera,
    availableCameras: state.availableCameras,
    currentCamera: state.currentCamera,
    configuration,
    updateConfiguration,
    clearHistory,
    clearError,
    processManualInput,
  };
}
