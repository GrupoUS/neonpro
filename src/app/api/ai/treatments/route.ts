// NEONPRO AI Treatment Recommendations API Route
// Phase 7 AI Integration - Streaming API for Treatment Recommendations
// Generated by VIBECODE SYSTEM V4.0 - AI Integration

import { db } from "@/lib/db";
import {
  ai_recommendation_history,
  ai_treatment_recommendations,
  appointments,
  patients,
  treatments,
} from "@/lib/schema";
import { createServerSupabaseClient } from "@/lib/supabase";
import { openai } from "@ai-sdk/openai";
import { streamText } from "ai";
import { and, desc, eq } from "drizzle-orm";
import { NextRequest, NextResponse } from "next/server";
import { z } from "zod";

// Validation Schema
const requestSchema = z.object({
  patient_id: z.string().uuid(),
  clinic_id: z.string().uuid(),
  aesthetic_goals: z
    .string()
    .min(10, "Please describe aesthetic goals in detail"),
  current_concerns: z.string().optional(),
  budget_range: z.string().optional(),
  timeline_preference: z.string().optional(),
  previous_treatments: z.array(z.string()).optional(),
  medical_conditions: z.string().optional(),
  allergies: z.string().optional(),
});

// Helper Functions
async function getPatientContext(patientId: string, clinicId: string) {
  // Get patient data
  const [patientData] = await db
    .select()
    .from(patients)
    .where(and(eq(patients.id, patientId), eq(patients.clinic_id, clinicId)))
    .limit(1);

  if (!patientData) {
    throw new Error("Patient not found");
  }

  // Get treatment history
  const treatmentHistory = await db
    .select({
      appointment: appointments,
      treatment: treatments,
    })
    .from(appointments)
    .leftJoin(treatments, eq(appointments.treatment_id, treatments.id))
    .where(eq(appointments.patient_id, patientId))
    .orderBy(desc(appointments.scheduled_at))
    .limit(10);

  // Get available treatments
  const availableTreatments = await db
    .select()
    .from(treatments)
    .where(
      and(eq(treatments.clinic_id, clinicId), eq(treatments.is_active, true))
    )
    .orderBy(treatments.category, treatments.name);

  return {
    patient: patientData,
    treatmentHistory,
    availableTreatments,
  };
}

function buildPrompt(context: any, input: any): string {
  const { patient, treatmentHistory, availableTreatments } = context;

  return `
You are an expert aesthetic medicine consultant for NEONPRO clinic. Based on the comprehensive patient information provided, recommend appropriate aesthetic treatments.

PATIENT INFORMATION:
- Medical History: ${JSON.stringify(patient.medical_history)}
- Known Allergies: ${patient.allergies || "None reported"}
- Additional Medical Conditions: ${input.medical_conditions || "None reported"}
- Additional Allergies: ${input.allergies || "None reported"}

AESTHETIC GOALS:
${input.aesthetic_goals}

CURRENT CONCERNS:
${input.current_concerns || "Not specified"}

PREFERENCES:
- Budget Range: ${input.budget_range || "Not specified"}
- Timeline: ${input.timeline_preference || "Flexible"}

TREATMENT HISTORY:
${
  treatmentHistory.length > 0
    ? treatmentHistory
        .map(
          (th: any) =>
            `- ${th.treatment?.name || "Unknown"} (${
              th.appointment.scheduled_at
            }): ${th.appointment.status}`
        )
        .join("\n")
    : "No previous treatments recorded"
}

PREVIOUS TREATMENTS MENTIONED:
${input.previous_treatments?.join(", ") || "None mentioned"}

AVAILABLE TREATMENTS AT CLINIC:
${availableTreatments
  .map(
    (t: any) =>
      `- ${t.name} (${t.category}): ${t.description} - Duration: ${t.duration_minutes}min, Price: R$${t.price}`
  )
  .join("\n")}

Please provide a comprehensive treatment recommendation including:

## PRIMARY RECOMMENDATIONS
Provide 2-3 most suitable treatments with:
- Treatment name and detailed rationale
- Expected outcomes and realistic timeline
- Estimated cost and number of sessions needed
- Why this treatment aligns with patient goals

## RISK ASSESSMENT
- Potential contraindications based on medical history
- Allergic reaction risks and precautions
- Side effects to monitor
- Pre-treatment requirements and preparations

## ALTERNATIVE OPTIONS
- Less invasive alternatives for conservative approach
- Budget-friendly options if cost is a concern
- Progressive treatment plans for gradual improvement

## FOLLOW-UP PLAN
- Recommended consultation and follow-up schedule
- Progress monitoring milestones and checkpoints
- Maintenance treatments for long-term results
- When to reassess goals and adjust treatment plan

## IMPORTANT CONSIDERATIONS
- Patient safety priorities and contraindications
- Realistic expectation setting and outcome predictions
- Lifestyle factors that may affect treatment success
- Post-treatment care requirements and restrictions

Always prioritize patient safety and evidence-based treatments. Provide realistic timelines and outcomes. Include appropriate medical disclaimers.
`.trim();
}

export async function POST(request: NextRequest) {
  try {
    // Validate authentication
    const supabase = await createServerSupabaseClient();
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Parse and validate request body
    const body = await request.json();
    const validatedInput = requestSchema.parse(body);

    // Get patient context
    const context = await getPatientContext(
      validatedInput.patient_id,
      validatedInput.clinic_id
    );

    // Build AI prompt
    const prompt = buildPrompt(context, validatedInput);

    // Create recommendation record
    const [newRecommendation] = await db
      .insert(ai_treatment_recommendations)
      .values({
        patient_id: validatedInput.patient_id,
        clinic_id: validatedInput.clinic_id,
        user_id: user.id,
        patient_data: {
          aesthetic_goals: validatedInput.aesthetic_goals,
          current_concerns: validatedInput.current_concerns,
          budget_range: validatedInput.budget_range,
          timeline_preference: validatedInput.timeline_preference,
          previous_treatments: validatedInput.previous_treatments,
          medical_conditions: validatedInput.medical_conditions,
          allergies: validatedInput.allergies,
        },
        aesthetic_goals: validatedInput.aesthetic_goals,
        treatment_history: context.treatmentHistory,
        recommendations: {}, // Will be updated after streaming
        ai_model: "gpt-4o",
        ai_version: "2024-11-20",
        confidence_score: "0.85",
      })
      .returning();

    // Log recommendation generation
    if (newRecommendation) {
      await db.insert(ai_recommendation_history).values({
        recommendation_id: newRecommendation.id,
        action: "generated",
        performed_by: user.id,
        notes: "AI treatment recommendation generation started",
        metadata: {
          prompt_length: prompt.length,
          available_treatments_count: context.availableTreatments.length,
          treatment_history_count: context.treatmentHistory.length,
        },
      });
    }

    // Generate streaming AI response
    const result = await streamText({
      model: openai("gpt-4o"),
      prompt,
      maxTokens: 3000,
      temperature: 0.6,
    });

    // Return streaming response with recommendation ID
    return new Response(result.textStream, {
      headers: {
        "Content-Type": "text/plain; charset=utf-8",
        "X-Recommendation-ID": newRecommendation?.id || "",
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "POST",
        "Access-Control-Allow-Headers": "Content-Type, Authorization",
      },
    });
  } catch (error) {
    console.error("AI Treatment Recommendation API Error:", error);

    if (error instanceof z.ZodError) {
      return NextResponse.json(
        {
          error: "Validation failed",
          details: error.errors,
        },
        { status: 400 }
      );
    }

    return NextResponse.json(
      {
        error: error instanceof Error ? error.message : "Internal server error",
      },
      { status: 500 }
    );
  }
}

// Handle preflight requests for CORS
export async function OPTIONS(request: NextRequest) {
  return new Response(null, {
    status: 200,
    headers: {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "POST, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization",
    },
  });
}
