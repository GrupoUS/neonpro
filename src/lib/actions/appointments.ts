// NEONPRO Server Actions - Appointments
// Type-safe Server Actions for Appointment Management
// Generated by VIBECODE SYSTEM V4.0 - Architectural Optimization

"use server";

import { db } from "@/lib/db";
import { appointments } from "@/lib/schema";
import { createServerSupabaseClient } from "@/lib/supabase";
import { and, eq, gte, lte } from "drizzle-orm";
import { revalidatePath } from "next/cache";
import { z } from "zod";

// Validation schemas
const createAppointmentSchema = z.object({
  patient_id: z.string().uuid(),
  treatment_id: z.string().uuid(),
  clinic_id: z.string().uuid(),
  scheduled_at: z.string().datetime(),
  notes: z.string().optional(),
});

const updateAppointmentSchema = z.object({
  id: z.string().uuid(),
  status: z
    .enum(["scheduled", "confirmed", "completed", "cancelled"])
    .optional(),
  notes: z.string().optional(),
  scheduled_at: z.string().datetime().optional(),
});

// Server Actions
export async function createAppointment(formData: FormData) {
  try {
    // Validate user authentication
    const supabase = await createServerSupabaseClient();
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      throw new Error("Unauthorized");
    }

    // Parse and validate form data
    const rawData = {
      patient_id: formData.get("patient_id") as string,
      treatment_id: formData.get("treatment_id") as string,
      clinic_id: formData.get("clinic_id") as string,
      scheduled_at: formData.get("scheduled_at") as string,
      notes: (formData.get("notes") as string) || undefined,
    };

    const validatedData = createAppointmentSchema.parse(rawData);

    // Create appointment in database
    const [newAppointment] = await db
      .insert(appointments)
      .values({
        ...validatedData,
        scheduled_at: new Date(validatedData.scheduled_at),
      })
      .returning();

    // Revalidate relevant pages
    revalidatePath("/dashboard/appointments");
    revalidatePath("/dashboard/calendar");

    return { success: true, appointment: newAppointment };
  } catch (error) {
    console.error("Error creating appointment:", error);
    return {
      success: false,
      error:
        error instanceof Error ? error.message : "Failed to create appointment",
    };
  }
}

export async function updateAppointment(formData: FormData) {
  try {
    // Validate user authentication
    const supabase = await createServerSupabaseClient();
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      throw new Error("Unauthorized");
    }

    // Parse and validate form data
    const rawData = {
      id: formData.get("id") as string,
      status: (formData.get("status") as string) || undefined,
      notes: (formData.get("notes") as string) || undefined,
      scheduled_at: (formData.get("scheduled_at") as string) || undefined,
    };

    const validatedData = updateAppointmentSchema.parse(rawData);

    // Update appointment in database
    const updateData: any = { ...validatedData };
    if (validatedData.scheduled_at) {
      updateData.scheduled_at = new Date(validatedData.scheduled_at);
    }
    delete updateData.id;

    const [updatedAppointment] = await db
      .update(appointments)
      .set({
        ...updateData,
        updated_at: new Date(),
      })
      .where(eq(appointments.id, validatedData.id))
      .returning();

    // Revalidate relevant pages
    revalidatePath("/dashboard/appointments");
    revalidatePath("/dashboard/calendar");

    return { success: true, appointment: updatedAppointment };
  } catch (error) {
    console.error("Error updating appointment:", error);
    return {
      success: false,
      error:
        error instanceof Error ? error.message : "Failed to update appointment",
    };
  }
}

export async function deleteAppointment(appointmentId: string) {
  try {
    // Validate user authentication
    const supabase = await createServerSupabaseClient();
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      throw new Error("Unauthorized");
    }

    // Delete appointment from database
    await db.delete(appointments).where(eq(appointments.id, appointmentId));

    // Revalidate relevant pages
    revalidatePath("/dashboard/appointments");
    revalidatePath("/dashboard/calendar");

    return { success: true };
  } catch (error) {
    console.error("Error deleting appointment:", error);
    return {
      success: false,
      error:
        error instanceof Error ? error.message : "Failed to delete appointment",
    };
  }
}

export async function getAppointmentsByDateRange(
  startDate: string,
  endDate: string
) {
  try {
    const supabase = await createServerSupabaseClient();
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      throw new Error("Unauthorized");
    }

    const appointmentsList = await db
      .select()
      .from(appointments)
      .where(
        and(
          gte(appointments.scheduled_at, new Date(startDate)),
          lte(appointments.scheduled_at, new Date(endDate))
        )
      );

    return { success: true, appointments: appointmentsList };
  } catch (error) {
    console.error("Error fetching appointments:", error);
    return {
      success: false,
      error:
        error instanceof Error ? error.message : "Failed to fetch appointments",
    };
  }
}
