// NEONPRO AI Treatment Recommendations Server Actions
// Phase 7 AI Integration - Streaming Server Actions for Treatment Recommendations
// Generated by VIBECODE SYSTEM V4.0 - AI Integration

"use server";

import { db } from "@/lib/db";
import {
  ai_recommendation_history,
  ai_treatment_recommendations,
  appointments,
  patients,
  treatments,
} from "@/lib/schema";
import { createServerSupabaseClient } from "@/lib/supabase";
import { openai } from "@ai-sdk/openai";
import { streamText } from "ai";
import { and, desc, eq } from "drizzle-orm";
import { revalidatePath } from "next/cache";
import { z } from "zod";

// Validation Schemas
const generateRecommendationSchema = z.object({
  patient_id: z.string().uuid(),
  clinic_id: z.string().uuid(),
  aesthetic_goals: z
    .string()
    .min(10, "Please describe aesthetic goals in detail"),
  current_concerns: z.string().optional(),
  budget_range: z.string().optional(),
  timeline_preference: z.string().optional(),
  previous_treatments: z.array(z.string()).optional(),
  medical_conditions: z.string().optional(),
  allergies: z.string().optional(),
});

const reviewRecommendationSchema = z.object({
  recommendation_id: z.string().uuid(),
  status: z.enum(["reviewed", "approved", "rejected"]),
  feedback: z.string().optional(),
  accuracy_rating: z.number().min(1).max(5).optional(),
});

// Types
export type GenerateRecommendationInput = z.infer<
  typeof generateRecommendationSchema
>;
export type ReviewRecommendationInput = z.infer<
  typeof reviewRecommendationSchema
>;

// Helper Functions
async function getPatientData(patientId: string, clinicId: string) {
  const [patientData] = await db
    .select({
      patient: patients,
      user: {
        id: patients.user_id,
        name: patients.user_id,
        email: patients.user_id,
      },
    })
    .from(patients)
    .where(and(eq(patients.id, patientId), eq(patients.clinic_id, clinicId)))
    .limit(1);

  if (!patientData) {
    throw new Error("Patient not found");
  }

  return patientData;
}

async function getTreatmentHistory(patientId: string) {
  const treatmentHistory = await db
    .select({
      appointment: appointments,
      treatment: treatments,
    })
    .from(appointments)
    .leftJoin(treatments, eq(appointments.treatment_id, treatments.id))
    .where(eq(appointments.patient_id, patientId))
    .orderBy(desc(appointments.scheduled_at))
    .limit(10);

  return treatmentHistory;
}

async function getAvailableTreatments(clinicId: string) {
  const availableTreatments = await db
    .select()
    .from(treatments)
    .where(
      and(eq(treatments.clinic_id, clinicId), eq(treatments.is_active, true))
    )
    .orderBy(treatments.category, treatments.name);

  return availableTreatments;
}

function buildTreatmentPrompt(
  patientData: any,
  treatmentHistory: any[],
  availableTreatments: any[],
  input: GenerateRecommendationInput
): string {
  const prompt = `
You are an expert aesthetic medicine consultant for NEONPRO clinic. Based on the comprehensive patient information provided, recommend appropriate aesthetic treatments.

PATIENT INFORMATION:
- Patient ID: ${input.patient_id}
- Medical History: ${JSON.stringify(patientData.patient.medical_history)}
- Known Allergies: ${patientData.patient.allergies || "None reported"}
- Additional Medical Conditions: ${input.medical_conditions || "None reported"}
- Additional Allergies: ${input.allergies || "None reported"}

AESTHETIC GOALS:
${input.aesthetic_goals}

CURRENT CONCERNS:
${input.current_concerns || "Not specified"}

PREFERENCES:
- Budget Range: ${input.budget_range || "Not specified"}
- Timeline: ${input.timeline_preference || "Flexible"}

TREATMENT HISTORY:
${
  treatmentHistory.length > 0
    ? treatmentHistory
        .map(
          (th) =>
            `- ${th.treatment?.name || "Unknown"} (${
              th.appointment.scheduled_at
            }): ${th.appointment.status}`
        )
        .join("\n")
    : "No previous treatments recorded"
}

PREVIOUS TREATMENTS MENTIONED:
${input.previous_treatments?.join(", ") || "None mentioned"}

AVAILABLE TREATMENTS AT CLINIC:
${availableTreatments
  .map(
    (t) =>
      `- ${t.name} (${t.category}): ${t.description} - Duration: ${t.duration_minutes}min, Price: R$${t.price}`
  )
  .join("\n")}

Please provide a comprehensive treatment recommendation including:

1. **PRIMARY RECOMMENDATIONS** (2-3 most suitable treatments)
   - Treatment name and rationale
   - Expected outcomes and timeline
   - Estimated cost and sessions needed
   - Why this treatment aligns with patient goals

2. **RISK ASSESSMENT**
   - Potential contraindications based on medical history
   - Allergic reaction risks
   - Side effects to monitor
   - Pre-treatment requirements

3. **ALTERNATIVE OPTIONS**
   - Less invasive alternatives
   - Budget-friendly options
   - Progressive treatment plans

4. **FOLLOW-UP PLAN**
   - Recommended consultation schedule
   - Progress monitoring milestones
   - Maintenance treatments
   - When to reassess goals

5. **IMPORTANT CONSIDERATIONS**
   - Patient safety priorities
   - Realistic expectation setting
   - Lifestyle factors to consider
   - Post-treatment care requirements

Always prioritize patient safety and evidence-based treatments. Provide realistic timelines and outcomes.
`;

  return prompt.trim();
}

// Server Actions
export async function generateTreatmentRecommendation(
  input: GenerateRecommendationInput
) {
  try {
    // Validate user authentication
    const supabase = await createServerSupabaseClient();
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      throw new Error("Unauthorized");
    }

    // Validate input
    const validatedInput = generateRecommendationSchema.parse(input);

    // Get patient data and context
    const patientData = await getPatientData(
      validatedInput.patient_id,
      validatedInput.clinic_id
    );
    const treatmentHistory = await getTreatmentHistory(
      validatedInput.patient_id
    );
    const availableTreatments = await getAvailableTreatments(
      validatedInput.clinic_id
    );

    // Build AI prompt
    const prompt = buildTreatmentPrompt(
      patientData,
      treatmentHistory,
      availableTreatments,
      validatedInput
    );

    // Generate streaming AI response
    const result = await streamText({
      model: openai("gpt-4o"),
      prompt,
      maxTokens: 3000,
      temperature: 0.6,
    });

    // Store recommendation in database (we'll get the full text after streaming)
    const [newRecommendation] = await db
      .insert(ai_treatment_recommendations)
      .values({
        patient_id: validatedInput.patient_id,
        clinic_id: validatedInput.clinic_id,
        user_id: user.id,
        patient_data: {
          aesthetic_goals: validatedInput.aesthetic_goals,
          current_concerns: validatedInput.current_concerns,
          budget_range: validatedInput.budget_range,
          timeline_preference: validatedInput.timeline_preference,
          previous_treatments: validatedInput.previous_treatments,
          medical_conditions: validatedInput.medical_conditions,
          allergies: validatedInput.allergies,
        },
        aesthetic_goals: validatedInput.aesthetic_goals,
        treatment_history: treatmentHistory,
        recommendations: {}, // Will be updated after streaming completes
        ai_model: "gpt-4o",
        ai_version: "2024-11-20",
        confidence_score: "0.85", // Default confidence
      })
      .returning();

    // Log recommendation generation
    if (newRecommendation) {
      await db.insert(ai_recommendation_history).values({
        recommendation_id: newRecommendation.id,
        action: "generated",
        performed_by: user.id,
        notes: "AI treatment recommendation generated",
        metadata: {
          prompt_length: prompt.length,
          available_treatments_count: availableTreatments.length,
          treatment_history_count: treatmentHistory.length,
        },
      });
    }

    // Revalidate relevant pages
    revalidatePath("/dashboard/patients");
    revalidatePath("/dashboard/treatments");
    revalidatePath("/dashboard/ai");

    return {
      success: true,
      recommendation: newRecommendation,
      stream: result.textStream,
    };
  } catch (error) {
    console.error("Error generating treatment recommendation:", error);
    return {
      success: false,
      error:
        error instanceof Error
          ? error.message
          : "Failed to generate recommendation",
    };
  }
}

export async function updateRecommendationWithResult(
  recommendationId: string,
  fullText: string,
  parsedRecommendations: any
) {
  try {
    const supabase = await createServerSupabaseClient();
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      throw new Error("Unauthorized");
    }

    // Update recommendation with full AI response
    const [updatedRecommendation] = await db
      .update(ai_treatment_recommendations)
      .set({
        rationale: fullText,
        recommendations: parsedRecommendations,
        updated_at: new Date(),
      })
      .where(eq(ai_treatment_recommendations.id, recommendationId))
      .returning();

    return { success: true, recommendation: updatedRecommendation };
  } catch (error) {
    console.error("Error updating recommendation:", error);
    return {
      success: false,
      error:
        error instanceof Error
          ? error.message
          : "Failed to update recommendation",
    };
  }
}

export async function reviewTreatmentRecommendation(
  input: ReviewRecommendationInput
) {
  try {
    // Validate user authentication
    const supabase = await createServerSupabaseClient();
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      throw new Error("Unauthorized");
    }

    // Validate input
    const validatedInput = reviewRecommendationSchema.parse(input);

    // Update recommendation status
    const [updatedRecommendation] = await db
      .update(ai_treatment_recommendations)
      .set({
        status: validatedInput.status,
        reviewed_by: user.id,
        feedback: validatedInput.feedback,
        accuracy_rating: validatedInput.accuracy_rating,
        updated_at: new Date(),
      })
      .where(
        eq(ai_treatment_recommendations.id, validatedInput.recommendation_id)
      )
      .returning();

    // Log review action
    await db.insert(ai_recommendation_history).values({
      recommendation_id: validatedInput.recommendation_id,
      action: validatedInput.status,
      performed_by: user.id,
      notes:
        validatedInput.feedback || `Recommendation ${validatedInput.status}`,
      metadata: {
        accuracy_rating: validatedInput.accuracy_rating,
      },
    });

    // Revalidate relevant pages
    revalidatePath("/dashboard/ai");
    revalidatePath("/dashboard/treatments");

    return { success: true, recommendation: updatedRecommendation };
  } catch (error) {
    console.error("Error reviewing recommendation:", error);
    return {
      success: false,
      error:
        error instanceof Error
          ? error.message
          : "Failed to review recommendation",
    };
  }
}

export async function getPatientRecommendations(
  patientId: string,
  clinicId: string
) {
  try {
    // Validate user authentication
    const supabase = await createServerSupabaseClient();
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      throw new Error("Unauthorized");
    }

    // Get patient recommendations
    const recommendations = await db
      .select()
      .from(ai_treatment_recommendations)
      .where(
        and(
          eq(ai_treatment_recommendations.patient_id, patientId),
          eq(ai_treatment_recommendations.clinic_id, clinicId)
        )
      )
      .orderBy(desc(ai_treatment_recommendations.created_at));

    return { success: true, recommendations };
  } catch (error) {
    console.error("Error fetching recommendations:", error);
    return {
      success: false,
      error:
        error instanceof Error
          ? error.message
          : "Failed to fetch recommendations",
    };
  }
}

export async function getRecommendationHistory(recommendationId: string) {
  try {
    // Validate user authentication
    const supabase = await createServerSupabaseClient();
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      throw new Error("Unauthorized");
    }

    // Get recommendation history
    const history = await db
      .select()
      .from(ai_recommendation_history)
      .where(eq(ai_recommendation_history.recommendation_id, recommendationId))
      .orderBy(desc(ai_recommendation_history.created_at));

    return { success: true, history };
  } catch (error) {
    console.error("Error fetching recommendation history:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Failed to fetch history",
    };
  }
}
