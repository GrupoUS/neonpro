# Story 2.1: Implement Modern Supabase Integration Patterns

## Status

Draft

## Story

**As a** Full-Stack Developer,
**I want** comprehensive modern Supabase integration patterns with Next.js 15,
**so that** I can implement secure, performant, and scalable authentication and data management for the aesthetic clinic system.

## Acceptance Criteria

1. Implement server-side authentication with secure cookie handling
2. Create comprehensive middleware for token refresh and route protection
3. Implement Row Level Security (RLS) policies for all patient data tables
4. Add real-time subscription patterns for clinic operations
5. Create type-safe Supabase client configurations
6. Implement OAuth and email verification flows
7. Add comprehensive error handling and retry mechanisms
8. Include performance optimization for database queries

## Tasks / Subtasks

### Phase 1: Server-Side Authentication Setup (AC: 1, 2)

- [ ] **Task 1.1: Supabase Client Configuration**
  - [ ] Create server component client
  - [ ] Create middleware client
  - [ ] Create browser client
  - [ ] Add environment variable validation

- [ ] **Task 1.2: Authentication Middleware Implementation**
  - [ ] Token refresh middleware
  - [ ] Route protection middleware
  - [ ] Session persistence middleware
  - [ ] Error handling middleware

- [ ] **Task 1.3: Protected Route Patterns**
  - [ ] Server component protection
  - [ ] API route protection
  - [ ] Client component protection
  - [ ] Redirect handling

### Phase 2: Row Level Security Implementation (AC: 3)

- [ ] **Task 2.1: Patient Data RLS Policies**
  - [ ] Patient profile access policies
  - [ ] Medical history access policies
  - [ ] Treatment record access policies
  - [ ] Appointment access policies

- [ ] **Task 2.2: Multi-Tenant RLS Policies**
  - [ ] Clinic-based data isolation
  - [ ] Staff role-based access
  - [ ] Doctor patient assignment
  - [ ] Admin clinic management

- [ ] **Task 2.3: RLS Policy Testing**
  - [ ] Unit tests for policy logic
  - [ ] Integration tests for data access
  - [ ] Performance tests for query optimization
  - [ ] Security audit tests

### Phase 3: Real-Time Integration (AC: 4)

- [ ] **Task 3.1: Real-Time Subscription Setup**
  - [ ] Appointment status subscriptions
  - [ ] Patient queue subscriptions
  - [ ] Treatment progress subscriptions
  - [ ] Communication subscriptions

- [ ] **Task 3.2: Real-Time UI Components**
  - [ ] Live appointment dashboard
  - [ ] Real-time patient queue
  - [ ] Live treatment tracking
  - [ ] Instant messaging components

- [ ] **Task 3.3: Conflict Resolution Patterns**
  - [ ] Optimistic updates
  - [ ] Conflict detection
  - [ ] Resolution strategies
  - [ ] Error recovery

### Phase 4: OAuth and Verification (AC: 6)

- [ ] **Task 4.1: OAuth Provider Setup**
  - [ ] Google OAuth integration
  - [ ] Social login UI components
  - [ ] OAuth error handling
  - [ ] Profile data synchronization

- [ ] **Task 4.2: Email Verification System**
  - [ ] Verification email templates
  - [ ] Verification flow handling
  - [ ] Resend verification logic
  - [ ] Verification status UI

### Phase 5: Type Safety and Performance (AC: 5, 8)

- [ ] **Task 5.1: TypeScript Integration**
  - [ ] Database type generation
  - [ ] Supabase client types
  - [ ] Auth types and guards
  - [ ] Real-time subscription types

- [ ] **Task 5.2: Performance Optimization**
  - [ ] Query optimization patterns
  - [ ] Connection pooling
  - [ ] Caching strategies
  - [ ] Bundle size optimization

## Dev Notes

### Supabase + Next.js 15 Integration Architecture

Modern server-side authentication pattern with secure cookie handling, eliminating the need for localStorage-based auth patterns.

### Server-Side Auth Pattern

```typescript
// Middleware (middleware.ts)
export async function middleware(request: NextRequest) {
  const { supabase, response } = createMiddlewareClient()
  await supabase.auth.getUser() // Refresh session
  return response
}

// Server Component
export default async function ProtectedPage() {
  const supabase = createServerComponentClient()
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) redirect('/login')
  return <Dashboard user={user} />
}
```

### RLS Policy Examples for Healthcare

```sql
-- Patient data access policy
CREATE POLICY "patient_data_access" ON patient_profiles
FOR ALL TO authenticated
USING (
  auth.uid() = user_id OR
  EXISTS (
    SELECT 1 FROM clinic_staff
    WHERE user_id = auth.uid()
    AND clinic_id = patient_profiles.clinic_id
  )
);

-- Clinic isolation policy
CREATE POLICY "clinic_isolation" ON appointments
FOR ALL TO authenticated
USING (
  clinic_id IN (
    SELECT clinic_id FROM user_clinic_access
    WHERE user_id = auth.uid()
  )
);
```

### Real-Time Subscription Patterns

```typescript
// Appointment status subscription
const { data, error } = await supabase
  .from('appointments')
  .select('*')
  .eq('clinic_id', clinicId)
  .on('*', (payload) => {
    updateAppointmentState(payload);
  })
  .subscribe();
```

### Type Generation Strategy

- Use Supabase CLI to generate types from database schema
- Create custom types for complex business logic
- Implement strict TypeScript configuration
- Add runtime type validation for external data

### Performance Considerations

- **Query Optimization**: Use proper indexes and query patterns
- **Connection Pooling**: Configure optimal connection limits
- **Caching**: Implement intelligent caching strategies
- **Bundle Size**: Tree-shake unused Supabase features

### Healthcare Domain Requirements

- **LGPD Compliance**: All data access must be logged and auditable
- **Multi-Tenant Security**: Strict data isolation between clinics
- **Real-Time Updates**: Critical for appointment scheduling and patient flow
- **Offline Capability**: Handle network interruptions gracefully

### File Structure

```
E:\neonpro\apps\web\src\lib\supabase\
├── server.ts          (Server component client)
├── middleware.ts      (Middleware client)
├── browser.ts         (Browser client)
├── types.ts          (Generated types)
└── policies.sql      (RLS policies)
```

### Testing Strategy

- **Unit Tests**: Individual auth functions
- **Integration Tests**: Full authentication flows
- **RLS Tests**: Policy enforcement validation
- **Performance Tests**: Query optimization validation
- **Security Tests**: Access control verification

### Environment Configuration

```env
NEXT_PUBLIC_SUPABASE_URL=
NEXT_PUBLIC_SUPABASE_ANON_KEY=
SUPABASE_SERVICE_ROLE_KEY=
```

### Error Handling Patterns

- Comprehensive error types for different failure modes
- Retry mechanisms for transient failures
- Graceful degradation for offline scenarios
- User-friendly error messages

## Change Log

| Date       | Version | Description            | Author      |
| ---------- | ------- | ---------------------- | ----------- |
| 2025-01-15 | 1.0     | Initial story creation | BMad Master |

## Dev Agent Record

_[To be populated by development agent during implementation]_

## QA Results

_[To be populated by QA agent during review]_
