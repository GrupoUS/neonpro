Of course. Here is a complete, production-ready Vercel deployment plan for the NeonPro monorepo.

This plan provides minimal, surgical changes to ensure a successful deployment on Vercel, aligning with your existing CI and documentation.

### 1. Vercel Configuration (`vercel.json`)

For simplicity and to leverage Vercel's automatic detection, the configuration file at `.deployment/vercel.json` should be moved to the root of the repository.

**Action:** Move `.deployment/vercel.json` to `vercel.json`.

I will now read the current configuration file to propose necessary changes.Here are the recommended adjustments for the new `vercel.json` at the root of your project.

**Proposed `vercel.json`:**

```json
{
  "$schema": "https://openapi.vercel.sh/vercel.json",
  "version": 2,
  "regions": ["gru1"],
  "installCommand": "pnpm install",
  "buildCommand": "pnpm turbo build --filter=@neonpro/api --filter=@neonpro/web...",
  "outputDirectory": "apps/web/dist",
  "functions": {
    "api/index.ts": {
      "runtime": "nodejs20.x",
      "memory": 1024
    }
  },
  "rewrites": [
    { "source": "/api/(.*)", "destination": "/api/index.ts" },
    { "source": "/((?!api|.*\\..*).*)", "destination": "/index.html" }
  ],
  "headers": [
    {
      "source": "/(.*)\\.(js|css|png|jpg|jpeg|gif|svg|ico|woff2)",
      "headers": [
        { "key": "Cache-Control", "value": "public, max-age=31536000, immutable" }
      ]
    },
    {
      "source": "/(.*)",
      "headers": [
        { "key": "Strict-Transport-Security", "value": "max-age=31536000; includeSubDomains; preload" },
        { "key": "X-Content-Type-Options", "value": "nosniff" },
        { "key": "X-Frame-Options", "value": "DENY" },
        { "key": "Referrer-Policy", "value": "strict-origin-when-cross-origin" },
        { "key": "Permissions-Policy", "value": "geolocation=(), microphone=(), camera=()" }
      ]
    }
  ]
}
```

**Reasoning for changes:**

1.  **`installCommand`**: Simplified to `pnpm install`. Vercel's build environment natively supports PNPM workspaces and will handle the installation correctly.
2.  **`buildCommand`**: Changed to `pnpm turbo build --filter=@neonpro/api --filter=@neonpro/web...`. This ensures that both the API and the web application are built, respecting the monorepo's dependency graph. The `...` at the end of the filter ensures that all dependencies of the web app are built.
3.  **`functions`**: The pattern `api/**/*.ts` is too broad. It should be explicitly `api/index.ts` to avoid accidentally creating other functions.
4.  **`env`**: The `env` block has been removed. Environment variables should be managed exclusively through the Vercel project settings (UI or CLI) for better security and management. Do not store them in `vercel.json`.

### 2. Environment Variable Strategy

The current use of `NEXT_PUBLIC_` prefixes for a Vite application is incorrect. Vite uses `VITE_` to expose environment variables to the client.

**Action:** Create a `.env.example` file in the root of the project with the corrected prefixes.

**Proposed `.env.example`:**

```
# ------------------------------------------------------------------
# Client-side (Vite) environment variables
# Exposed to the browser, prefixed with VITE_
# ------------------------------------------------------------------
VITE_SUPABASE_URL="your-supabase-url"
VITE_SUPABASE_ANON_KEY="your-supabase-anon-key"

# ------------------------------------------------------------------
# Server-side (Hono API) environment variables
# NOT exposed to the browser.
# These must be set in your Vercel project settings.
# ------------------------------------------------------------------
DATABASE_URL="your-postgres-connection-string"
DIRECT_URL="your-postgres-direct-connection-string"
SUPABASE_SERVICE_ROLE_KEY="your-supabase-service-role-key"
```

**Security:** To prevent accidental leakage of server-side secrets into the client bundle, I recommend adding a build step to scan the output. You can use a script with `grep` to check for `SUPABASE_SERVICE_ROLE_KEY` in the `apps/web/dist` directory.

### 3. Test-First Approach (TDD)

Following the TDD plan, I'll first adjust the tests to expect the desired response, then change the application code. The health check response should be standardized to `{ "status": "ok" }`.

I will now search for the relevant test files.The relevant files are `/root/neonpro/apps/api/src/__tests__/routes/health.test.ts` and `/root/neonpro/apps/api/src/__tests__/routes/openapi.test.ts`. I will now read them.
The tests are already written and expecting the correct responses. Now, I will read the application code to propose the necessary changes to make these tests pass.**Patch for `apps/api/src/app.ts`:**

```diff
--- a/apps/api/src/app.ts
+++ b/apps/api/src/app.ts
@@ -1,5 +1,7 @@
 import { Hono } from 'hono'
+import { OpenAPIHono } from '@hono/zod-openapi'
 import auth from './routes/auth'
 import patients from './routes/patients'
 import appointments from './routes/appointments'
 
 // Minimal Hono application exported for Vercel handler consumption.
 // Note: We use basePath('/api') so that requests rewritten from
 // '/api/*' map cleanly to these routes.
-const app = new Hono().basePath('/api')
+const app = new OpenAPIHono().basePath('/api')
 
 app.get('/', (c) =>
   c.json({
@@ -11,7 +13,7 @@
 
 app.get('/health', (c) =>
   c.json({
-    status: 'healthy',
+    status: 'ok',
     uptime: process.uptime(),
     timestamp: new Date().toISOString(),
   }),
@@ -43,4 +45,12 @@
 
 app.route('/v1', v1)
 
+// OpenAPI documentation route
+app.doc('/openapi.json', {
+  openapi: '3.1.0',
+  info: {
+    version: '1.0.0',
+    title: 'NeonPro API',
+  },
+})
+
 export { app }

```

**Reasoning for patch:**

1.  **Health Check:** The `/health` endpoint is changed to return `{ "status": "ok" }` to match the test expectation.
2.  **OpenAPI:**
    *   The app is changed from `Hono` to `OpenAPIHono` to support OpenAPI documentation generation.
    *   An OpenAPI documentation endpoint is added at `/openapi.json`, which will make the `openapi.test.ts` test pass.

### 4. Hono Runtime: Node.js vs. Edge

For the Hono API, you have two runtime choices on Vercel:

*   **Node.js (Recommended for now):**
    *   **Pros:** Full compatibility with all Node.js APIs and libraries, including those with native dependencies. Prisma works out-of-the-box.
    *   **Cons:** Can have slower "cold starts" compared to the Edge runtime.
*   **Edge:**
    *   **Pros:** Extremely fast, with near-zero cold starts.
    *   **Cons:** The runtime is a subset of standard browser APIs, not Node.js. This can limit library compatibility. For Prisma, you must use the Prisma Data Proxy or Accelerate, which may add complexity and cost.

**Recommendation:** Start with the `nodejs20.x` runtime as configured. It provides the most stability and compatibility. You can later optimize specific, performance-critical endpoints to the Edge runtime.

**To switch to Edge:** You would change the `runtime` in `vercel.json` for the specific function:

```json
"functions": {
  "api/index.ts": {
    "runtime": "edge"
  }
}
```

### 5. Supabase + Prisma

To ensure `prisma generate` runs correctly during Vercel's build process, it should be part of the `build` script for the `api` package.

**Action:** Modify the `build` script in `apps/api/package.json`.

**Proposed `apps/api/package.json` change:**

```json
"scripts": {
  "dev": "tsx watch src/index.ts",
  "build": "prisma generate --schema=../../packages/database/prisma/schema.prisma && tsup",
  "start": "node dist/index.js",
  "test": "vitest run"
}
```

This ensures that the Prisma client is generated with the correct schema location before the application is bundled with `tsup`.

### 6. CI Alignment

With `vercel.json` moved to the root, the CI commands in `.github/workflows/ci.yml` are straightforward.

**Proposed `deploy-vercel` job in `.github/workflows/ci.yml`:**

```yaml
deploy-vercel:
  runs-on: ubuntu-latest
  needs: [lint, type-check, tests] # Or other prerequisite jobs
  if: github.ref == 'refs/heads/main' # Or your production branch
  steps:
    - name: Checkout code
      uses: actions/checkout@v4
    - name: Install PNPM
      uses: pnpm/action-setup@v3
      with:
        version: 9
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: 20
        cache: 'pnpm'
    - name: Install dependencies
      run: pnpm install
    - name: Pull Vercel project settings
      run: vercel pull --yes --environment=production --token=${{ secrets.VERCEL_TOKEN }}
    - name: Build project
      run: vercel build --prod --token=${{ secrets.VERCEL_TOKEN }}
    - name: Deploy to Vercel
      run: vercel deploy --prebuilt --prod --token=${{ secrets.VERCEL_TOKEN }}
```

Ensure the `VERCEL_TOKEN`, `VERCEL_ORG_ID`, and `VERCEL_PROJECT_ID` are set as secrets in your GitHub repository.

### 7. Smoke Test Plan

After a deployment, run this script to verify that the frontend and API are healthy.

```bash
#!/bin/bash

# Replace with your production URL
PROD_URL="https://your-project-name.vercel.app"

echo "Smoke Test: Checking frontend..."
FRONTEND_STATUS=$(curl -o /dev/null -s -w "%{http_code}" $PROD_URL)

if [ "$FRONTEND_STATUS" -eq 200 ]; then
  echo "✅ Frontend is up (Status: $FRONTEND_STATUS)"
else
  echo "❌ Frontend is DOWN (Status: $FRONTEND_STATUS)"
  exit 1
fi

echo "Smoke Test: Checking API health..."
API_HEALTH_URL="$PROD_URL/api/health"
API_RESPONSE=$(curl -s $API_HEALTH_URL)
API_STATUS=$(echo $API_RESPONSE | jq -r '.status')

if [ "$API_STATUS" == "ok" ]; then
  echo "✅ API is healthy (Response: $API_RESPONSE)"
else
  echo "❌ API is unhealthy or returned an unexpected response (Response: $API_RESPONSE)"
  exit 1
fi

echo "Smoke tests passed!"
exit 0
```

### 8. Rollback Plan

If a deployment introduces a critical issue, you can instantly roll back using the Vercel CLI or dashboard.

**CLI Command:**

1.  Find the deployment URL you want to revert to by running:
    ```bash
    vercel list --prod
    ```
2.  From the list, copy the URL of a previous, stable deployment.
3.  Run the `vercel rollback` command with that URL:
    ```bash
    vercel rollback <deployment-url-from-previous-step>
    ```

**Dashboard:**

1.  Go to your project on Vercel.
2.  Navigate to the "Deployments" tab.
3.  Find the deployment you wish to restore.
4.  Click the "..." menu and select "Promote to Production".

### 9. Security Headers & Caching

The headers in your `vercel.json` are excellent. The `Cache-Control` header for static assets is correctly configured for immutable caching. For API routes, Hono (and Express-like frameworks) typically do not set a `Cache-Control` header, which defaults to `no-cache` or `no-store` in most browsers, which is the desired behavior for dynamic content.

### 10. Monorepo Pitfalls on Vercel

The primary pitfall with monorepos on Vercel is ensuring that serverless functions can resolve their dependencies from other workspace packages.

**Mitigation:** Your setup already uses the best practice for this: **pre-bundling the API with `tsup`**. By bundling your Hono application into a single file (or a small number of files), you eliminate the need for Vercel's builders to traverse the `node_modules` of multiple packages. The `api/index.ts` should import the bundled application from `apps/api/dist/index.js`.

I will now check `api/index.ts` to ensure it's importing from the correct location.The `api/index.ts` file is importing directly from the source `src` directory. This will fail in production. It must import from the build output.

**Patch for `api/index.ts`:**

```diff
--- a/api/index.ts
+++ b/api/index.ts
@@ -1,4 +1,4 @@
-import { app } from '../apps/api/src/app'
+import { app } from '../apps/api/dist/index.js'
 
 // Per Vercel’s Hono guide, export the Hono app as the default export.
 // Vercel will treat routes defined on this app as Functions automatically.

```

This final change ensures that the Vercel function uses the bundled, production-ready code. This completes the deployment plan.
