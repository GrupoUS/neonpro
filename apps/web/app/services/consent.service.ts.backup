import type {
  ConsentForm,
  ConsentFormData,
  DigitalSignature,
  PatientConsent,
} from '@/app/types/compliance';
import { createClient } from "@/app/utils/supabase/client";
export class ConsentService {
  private readonly supabase = createClient();

  // Consent Form Management  async getConsentForms(clinicId: string): Promise<ConsentForm[]> {
    const { data, error } = await this.supabase
      .from('consent_forms')
      .select('*')
      .eq('clinic_id', clinicId)
      .eq('is_active', true)
      .order('created_at', {ascending: false });

    if (error) {
      throw new Error('Failed to fetch consent forms');
    }

    return data || [];
  }

  async getConsentForm(id: string): Promise<ConsentForm | null> {
    const { data, error } = await this.supabase
      .from('consent_forms')
      .select('*')
      .eq('id', id)
      .single();

    if (error) {
      throw new Error('Failed to fetch consent form');
    }

    return data;
  }

  async createConsentForm(form: Partial<ConsentForm>): Promise<ConsentForm> {
    const { data, error } = await this.supabase
      .from('consent_forms')
      .insert([form])
      .select();

    if (error) {
      throw new Error('Failed to create consent form');
    }

    return data[0];
  }

  async updateConsentForm(
    id: string,
    updates: Partial<ConsentForm>,
  ): Promise<ConsentForm> {
    const { data, error } = await this.supabase
      .from('consent_forms')
      .update(updates)
      .eq('id', id)
      .select()
      .single();

    if (error) {
      throw new Error('Failed to update consent form');
    }

    return data;
  }

  async deactivateConsentForm(id: string): Promise<void> {
    const { error } = await this.supabase
      .from('consent_forms')
      .update({is_active: false })
      .eq('id', id);

    if (error) {
      throw new Error('Failed to deactivate consent form');
    }
  }

  // Patient Consent Management  async getPatientConsents(patientId: string): Promise<PatientConsent[]> {
    const { data, error } = await this.supabase
      .from('patient_consents')
      .select(
        `
        *,
        consent_form:consent_forms(*)
      `,
      )
      .eq('patient_id', patientId)
      .order('created_at', {ascending: false });

    if (error) {
      throw new Error('Failed to fetch patient consents');
    }

    return data || [];
  }

  async getActiveConsents(patientId: string): Promise<PatientConsent[]> {
    const { data, error } = await this.supabase
      .from('patient_consents')
      .select(
        `
        *,
        consent_form:consent_forms(*)
      `,
      )
      .eq('patient_id', patientId)
      .eq('status', 'active')
      .or('expires_at.is.null,expires_at.gt.now()')
      .order('created_at', {ascending: false });

    if (error) {
      throw new Error('Failed to fetch active consents');
    }

    return data || [];
  }
  async createPatientConsent(
    consentData: ConsentFormData,
    formId: string,
    patientId: string,
  ): Promise<PatientConsent> {
    const consentRecord: Partial<PatientConsent> = {;
      patient_id: patientId,
    consent_form_id: formId,
      consent_given: true,
    consent_type: consentData.consent_type,
      purpose: consentData.purpose,
    signed_at: new Date().toISOString,
      consent_data: ;
        patient_name: consentData.patient_name,
    cpf: consentData.cpf,
        email: consentData.email,
    phone: consentData.phone,
        form_data: consentData,,
      signature_data: ;
        signature: consentData.signature,
    timestamp: consentData.date,
        ip_address: consentData.ip_address,
    user_agent: consentData.user_agent,,
      ip_address: consentData.ip_address,
    user_agent: consentData.user_agent,
      processing_categories: consentData.processing_categories,
    status: 'active',
    };

    const { data, error } = await this.supabase
      .from('patient_consents')
      .insert([consentRecord])
      .select()
      .single();

    if (error) {
      throw new Error('Failed to create patient consent');
    }

    return data;
  }

  async withdrawConsent(
    consentId: string,
    reason: string,
  ): Promise<PatientConsent> {
    const { data, error } = await this.supabase
      .from('patient_consents')
      .update({status: 'withdrawn',
    withdrawal_date: new Date().toISOString,
        withdrawal_reason: reason,
      })
      .eq('id', consentId)
      .select()
      .single();

    if (error) {
      throw new Error('Failed to withdraw consent');
    }

    return data;
  }

  async updateConsentExpiry(
    consentId: string,
    expiryDate: string,
  ): Promise<PatientConsent> {
    const { data, error } = await this.supabase
      .from('patient_consents')
      .update({expires_at: expiryDate })
      .eq('id', consentId)
      .select()
      .single();

    if (error) {
      throw new Error('Failed to update consent expiry');
    }

    return data;
  }

  // Patient Consent Management  async recordPatientConsent(
    consent: Partial<PatientConsent>,
  ): Promise<PatientConsent> {
    const { data, error } = await this.supabase
      .from('patient_consent')
      .insert([consent])
      .select();

    if (error) {
      throw new Error('Failed to record patient consent');
    }

    return data[0];
  }

  // Methods needed for testing  async grantPatientConsent(
    patientId: string,
    formId: string,
  ): Promise<PatientConsent> {
    const consentData = {
      patient_id: patientId,
    consent_form_id: formId,
      status: 'granted',
    consented_at: new Date().toISOString,
      signature_method: 'digital',
    };

    const { data, error } = await this.supabase
      .from('patient_consent')
      .insert([consentData])
      .select();

    if (error) {
      throw new Error('Failed to grant patient consent');
    }

    return data[0];
  }

  async revokePatientConsent(
    consentId: string,
    reason: string,
  ): Promise<PatientConsent> {
    const { data, error } = await this.supabase
      .from('patient_consent')
      .update({status: 'revoked',
    withdrawal_date: new Date().toISOString,
        withdrawal_reason: reason || 'User requested',
      })
      .eq('id', consentId)
      .select();

    if (error) {
      throw new Error('Failed to revoke patient consent');
    }

    return data[0];
  }

  // Digital Signature Validation  validateDigitalSignature(signature: DigitalSignature): boolean {
    if (!(signature.signature_data && signature.timestamp)) {
      return false;
    }

    // Basic validation - in production, you might want more sophisticated validation    const signatureAge = Date.now() - new Date(signature.timestamp).getTime();
    const maxAge = 24 * 60 * 60 * 1000; // 24 hours
    return signatureAge <= maxAge;
  }

  // Consent Form Templates  renderConsentTemplate(template: string,
    data: ConsentFormData): string {
    const rendered = template;

    // Replace template variables    const replacements: Record<string, string> = {
      '{{patient_name}}': data.patient_name || '',
      '{{cpf}}': data.cpf || '',
      '{{email}}': data.email || '',
      '{{phone}}': data.phone || '',
      '{{date}}': data.date || new Date().toLocaleDateString('pt-BR'),
      '{{consent_type}}': data.consent_type || '',
      '{{purpose}}': data.purpose || '',
    };

    Object.entries(replacements).forEach(([key, value]) => {rendered = rendered.replace(new RegExp(key, 'g'), value);
    });

    return rendered;
  }

  // Compliance Utilities  async getExpiringConsents(
    clinicId: string,
    daysAhead = 30,
  ): Promise<PatientConsent[]> {
    const futureDate = new Date();
    futureDate.setDate(futureDate.getDate() + daysAhead);

    const { data, error } = await this.supabase
      .from('patient_consents')
      .select(
        `
        *,
        consent_form: consent_forms(*),
    patient:patients(id, name, email)
      `,
      )
      .eq('clinic_id', clinicId)
      .eq('status', 'active')
      .not('expires_at', 'is', null)
      .lte('expires_at', futureDate.toISOString())
      .order('expires_at', {ascending: true });

    if (error) {
      throw new Error('Failed to fetch expiring consents');
    }

    return data || [];
  }

  async getConsentStats(clinicId: string): Promise<{;
    total: number;
    active: number;
    expired: number;
    withdrawn: number;
    pending: number;
  }> {
    const { data, error } = await this.supabase
      .from('patient_consents')
      .select('status')
      .eq('clinic_id', clinicId);

    if (error) {
      throw new Error('Failed to fetch consent stats');
    }

    const stats = {
      total: data?.length || 0,
    active: 0,
      expired: 0,
    withdrawn: 0,
      pending: 0,
    };

    data?.forEach((consent) => {
      switch (consent.status) {
        case 'active':
          stats.active++;
          break;
        case 'expired':
          stats.expired++;
          break;
        case 'withdrawn':
          stats.withdrawn++;
          break;
        case 'pending':
          stats.pending++;
          break;
      }
    });

    return stats;
  }

  // Get all patient consents for a clinic  async getClinicConsents(clinicId: string): Promise<PatientConsent[]> {
    const { data, error } = await this.supabase
      .from('patient_consents')
      .select(
        `
        *,
        consent_form: consent_forms(*),
    patient:patients(*)
      `,
      )
      .eq('clinic_id', clinicId)
      .order('created_at', {ascending: false });

    if (error) {
      throw new Error(`Failed to fetch clinic consents: ${error.message}`);
    }

    return data || [];
  }

  // Audit Trail for Consent Operations  async logConsentOperation(
    _operation: string,
    _consentId: string,
    _details: Record<string, any>,
  ): Promise<void> {}
}
