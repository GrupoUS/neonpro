// =====================================================================================// TREATMENT FOLLOW-UP HOOKS// Epic 7.3: React hooks for follow-up automation UI integration// =====================================================================================
'use client';

import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { toast } from "react-hot-toast";
import { treatmentFollowupService } from "@/app/lib/services/treatment-followup-service";
import type {
  CreateFollowupData,
  CreateFollowupTemplateData,
  CreateTreatmentProtocolData,
  FollowupFilters,
  FollowupTemplate,
  ProtocolFilters,
  TemplateFilters,
  TreatmentFollowup,
} from '@/app/types/treatment-followups';

// =====================================================================================// QUERY KEYS// =====================================================================================
const QUERY_KEYS = {
  followups: (filters ? null : FollowupFilters) => ['followups', filters],
  followup: (id: string) => ['followups', id],
  templates: (filters?: TemplateFilters) => ['followup-templates', filters],
  template: (id: string) => ['followup-templates', id],
  protocols: (filters?: ProtocolFilters) => ['treatment-protocols', filters],
  protocol: (id: string) => ['treatment-protocols', id],
  analytics: (clinicId: string, dateFrom?: string, dateTo?: string) => [
    'followup-analytics',
    clinicId,
    dateFrom,
    dateTo,
  ],
  dashboardSummary: (clinicId: string) => ['followup-dashboard', clinicId]
} as const;

// =====================================================================================// FOLLOW-UP HOOKS// =====================================================================================
/**
 * Hook to fetch follow-ups with filters
 */
export function useFollowups(filters ? null : FollowupFilters) {return useQuery({
    queryKey: QUERY_KEYS.followups(filters),
    queryFn:  => treatmentFollowupService.getFollowups(filters),
    staleTime: 1000 * 60 * 5, // 5 minutes    cacheTime: 1000 * 60 * 10, // 10 minutes    retry: 2,
    refetchOnWindowFocus: false,
  });
}

/**
 * Hook to fetch single follow-up by ID
 */
export function useFollowup(id: string) {return useQuery({
    queryKey: QUERY_KEYS.followup(id),
    queryFn:  => treatmentFollowupService.getFollowupById(id),
    enabled: Boolean(id),
    staleTime: 1000 * 60 * 5,
    cacheTime: 1000 * 60 * 10,
    retry: 2,
  });
}

/**
 * Hook to create new follow-up
 */
export function useCreateFollowup() {const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: CreateFollowupData) = />;
      treatmentFollowupService.createFollowup(data),
    onSuccess: (newFollowup) => {
      // Invalidate and refetch follow-ups list      queryClient.invalidateQueries({ queryKey: ['followups'] });
      queryClient.invalidateQueries({queryKey: ['followup-dashboard'] });

      // Add to cache      queryClient.setQueryData(
        QUERY_KEYS.followup(newFollowup.id),
        newFollowup,
      );

      toast.success('Follow-up criado com sucesso!');
    },
    onError: (error: Error) => {
      toast.error(`Erro ao criar follow-up: ${error.message}`);
    },
  });
}

/**
 * Hook to update follow-up
 */
export function useUpdateFollowup() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      id,
      updates,
    }: {id: string;
      updates: Partial<TreatmentFollowup>;
    }) => treatmentFollowupService.updateFollowup(id, updates),
    onSuccess: (updatedFollowup) => {// Update specific follow-up in cache      queryClient.setQueryData(
        QUERY_KEYS.followup(updatedFollowup.id),
        updatedFollowup,
      );

      // Invalidate follow-ups list      queryClient.invalidateQueries({ queryKey: ['followups'] });
      queryClient.invalidateQueries({queryKey: ['followup-dashboard'] });

      toast.success('Follow-up atualizado com sucesso!');
    },
    onError: (error: Error) => {
      toast.error(`Erro ao atualizar follow-up: ${error.message}`);
    },
  });
}

/**
 * Hook to delete follow-up
 */
export function useDeleteFollowup() {const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id: string) => treatmentFollowupService.deleteFollowup(id),
    onSuccess: (_, deletedId) => {
      // Remove from cache      queryClient.removeQueries({ queryKey: QUERY_KEYS.followup(deletedId) });

      // Invalidate follow-ups list      queryClient.invalidateQueries({queryKey: ['followups'] });
      queryClient.invalidateQueries({queryKey: ['followup-dashboard'] });

      toast.success('Follow-up excluído com sucesso!');
    },
    onError: (error: Error) => {
      toast.error(`Erro ao excluir follow-up: ${error.message}`);
    },
  });
}

/**
 * Hook to complete follow-up
 */
export function useCompleteFollowup() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, notes }: {id: string; notes: string }) = />;
      treatmentFollowupService.completeFollowup(id, notes),
    onSuccess: (completedFollowup) => {// Update specific follow-up in cache      queryClient.setQueryData(
        QUERY_KEYS.followup(completedFollowup.id),
        completedFollowup,
      );

      // Invalidate follow-ups list      queryClient.invalidateQueries({ queryKey: ['followups'] });
      queryClient.invalidateQueries({queryKey: ['followup-dashboard'] });

      toast.success('Follow-up marcado como concluído!');
    },
    onError: (error: Error) => {
      toast.error(`Erro ao concluir follow-up: ${error.message}`);
    },
  });
}

// =====================================================================================// TEMPLATE HOOKS// =====================================================================================
/**
 * Hook to fetch follow-up templates
 */
export function useFollowupTemplates(filters ? null : TemplateFilters) {return useQuery({
    queryKey: QUERY_KEYS.templates(filters),
    queryFn:  => treatmentFollowupService.getTemplates(filters),
    staleTime: 1000 * 60 * 10, // 10 minutes (templates change less frequently)    cacheTime: 1000 * 60 * 30, // 30 minutes    retry: 2,
    refetchOnWindowFocus: false,
  });
}

/**
 * Hook to create follow-up template
 */
export function useCreateFollowupTemplate() {const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: CreateFollowupTemplateData) = />;
      treatmentFollowupService.createTemplate(data),
    onSuccess: (newTemplate) => {
      // Invalidate templates list      queryClient.invalidateQueries({ queryKey: ['followup-templates'] });

      // Add to cache      queryClient.setQueryData(
        QUERY_KEYS.template(newTemplate.id),
        newTemplate,
      );

      toast.success('Template de follow-up criado com sucesso!');
    },
    onError: (error: Error) => {
      toast.error(`Erro ao criar template: ${error.message}`);
    },
  });
}

/**
 * Hook to update follow-up template
 */
export function useUpdateFollowupTemplate() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({
      id,
      updates,
    }: {id: string;
      updates: Partial<FollowupTemplate>;
    }) => treatmentFollowupService.updateTemplate(id, updates),
    onSuccess: (updatedTemplate) => {// Update specific template in cache      queryClient.setQueryData(
        QUERY_KEYS.template(updatedTemplate.id),
        updatedTemplate,
      );

      // Invalidate templates list      queryClient.invalidateQueries({ queryKey: ['followup-templates'] });

      toast.success('Template atualizado com sucesso!');
    },
    onError: (error: Error) => {
      toast.error(`Erro ao atualizar template: ${error.message}`);
    },
  });
}

// =====================================================================================// PROTOCOL HOOKS// =====================================================================================
/**
 * Hook to fetch treatment protocols
 */
export function useTreatmentProtocols(filters ? null : ProtocolFilters) {return useQuery({
    queryKey: QUERY_KEYS.protocols(filters),
    queryFn:  => treatmentFollowupService.getProtocols(filters),
    staleTime: 1000 * 60 * 15, // 15 minutes (protocols change rarely)    cacheTime: 1000 * 60 * 60, // 1 hour    retry: 2,
    refetchOnWindowFocus: false,
  });
}

/**
 * Hook to create treatment protocol
 */
export function useCreateTreatmentProtocol() {const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: CreateTreatmentProtocolData) = />;
      treatmentFollowupService.createProtocol(data),
    onSuccess: (newProtocol) => {
      // Invalidate protocols list      queryClient.invalidateQueries({ queryKey: ['treatment-protocols'] });

      // Add to cache      queryClient.setQueryData(
        QUERY_KEYS.protocol(newProtocol.id),
        newProtocol,
      );

      toast.success('Protocolo de tratamento criado com sucesso!');
    },
    onError: (error: Error) => {
      toast.error(`Erro ao criar protocolo: ${error.message}`);
    },
  });
}

// =====================================================================================// ANALYTICS HOOKS// =====================================================================================
/**
 * Hook to fetch follow-up analytics
 */
export function useFollowupAnalytics(
  clinicId: string,
    dateFrom: string,
  dateTo?: string,
) {return useQuery({
    queryKey: QUERY_KEYS.analytics(clinicId, dateFrom, dateTo),
    queryFn:  = />;
      treatmentFollowupService.getAnalytics(clinicId, dateFrom, dateTo),
    enabled: Boolean(clinicId),
    staleTime: 1000 * 60 * 5, // 5 minutes    cacheTime: 1000 * 60 * 15, // 15 minutes    retry: 2,
    refetchOnWindowFocus: false,
  });
}

/**
 * Hook to fetch dashboard summary
 */
export function useFollowupDashboardSummary(clinicId: string) {return useQuery({
    queryKey: QUERY_KEYS.dashboardSummary(clinicId),
    queryFn:  => treatmentFollowupService.getDashboardSummary(clinicId),
    enabled: Boolean(clinicId),
    staleTime: 1000 * 60 * 2, // 2 minutes (dashboard needs fresher data)    cacheTime: 1000 * 60 * 5, // 5 minutes    retry: 2,
    refetchOnWindowFocus: true, // Refetch when returning to dashboard    refetchInterval: 1000 * 60 * 5, // Auto-refresh every 5 minutes  });
}

// =====================================================================================// UTILITY HOOKS// =====================================================================================
/**
 * Hook to get today's follow-ups
 */
export function useTodayFollowups(clinicId: string) {const today = new Date();
  const todayStart = new Date(
    today.getFullYear,
    today.getMonth(),
    today.getDate(),
  );
  const todayEnd = new Date(
    today.getFullYear(),
    today.getMonth(),
    today.getDate() + 1,
  );

  return useFollowups({
    clinic_id: clinicId,
    date_from: todayStart.toISOString,
    date_to: todayEnd.toISOString,
    limit: 50,
  });
}

/**
 * Hook to get pending follow-ups
 */
export function usePendingFollowups(clinicId: string) {return useFollowups({
    clinic_id: clinicId,
    status: ['pending'],
    limit: 100,
  });
}

/**
 * Hook to get overdue follow-ups
 */
export function useOverdueFollowups(clinicId: string) {const now = new Date().toISOString;

  return useFollowups({
    clinic_id: clinicId,
    status: ['pending'],
    date_to: now,
    limit: 50,
  });
}

/**
 * Hook to get active templates for a clinic
 */
export function useActiveFollowupTemplates(clinicId: string) {return useFollowupTemplates({
    clinic_id: clinicId,
    active: true,
    limit: 100,
  });
}

/**
 * Hook to get active protocols for a clinic
 */
export function useActiveTreatmentProtocols(clinicId: string) {return useTreatmentProtocols({
    clinic_id: clinicId,
    active: true,
    limit: 100,
  });
}
