// Custom Report Builder Service
// Story 8.2: Custom Report Builder (Drag-Drop Interface)

import type {
  CreateReportRequest,
  CustomReport,
  DataSourceConnector,
  GenerateReportRequest,
  ReportAnalyticsResponse,
  ReportCollaborator,
  ReportComment,
  ReportListResponse,
  ReportSchedule,
  ReportTemplate,
  TemplateListResponse,
  UpdateReportRequest,
} from '@/app/types/report-builder';
import { createClient } from '@/app/utils/supabase/server';

export class ReportBuilderService {
  private readonly supabase;

  constructor() {
    this.supabase = createClient();
  }

  // Custom Reports Management
  async createReport(data: CreateReportRequest): Promise<CustomReport> {
    const {
      data: { user },
    } = await this.supabase.auth.getUser();
    if (!user) {
      throw new Error('User not authenticated');
    }

    const { data: profile } = await this.supabase
      .from('user_profiles')
      .select('clinic_id')
      .eq('user_id', user.id)
      .single();

    if (!profile) {
      throw new Error('User profile not found');
    }

    // If using a template, fetch template config
    let templateConfig = {};
    if (data.template_id) {
      const { data: template } = await this.supabase
        .from('report_templates')
        .select('config_json')
        .eq('id', data.template_id)
        .single();

      if (template) {
        templateConfig = template.config_json;
      }
    }

    const reportData = {
      report_name: data.report_name,
      report_description: data.report_description,
      report_config: data.report_config || templateConfig,
      data_sources: data.data_sources || [],
      visualization_type: data.visualization_type || 'dashboard',
      filters: {},
      layout_config: {},
      is_template: false,
      is_public: data.is_public,
      user_id: user.id,
      clinic_id: profile.clinic_id,
      generation_count: 0,
    };

    const { data: report, error } = await this.supabase
      .from('custom_reports')
      .insert([reportData])
      .select()
      .single();

    if (error) {
      throw new Error(`Failed to create report: ${error.message}`);
    }

    // Track usage
    await this.trackUsage(report.id, user.id, 'edit');

    return report;
  }

  async updateReport(
    reportId: string,
    data: UpdateReportRequest,
  ): Promise<CustomReport> {
    const {
      data: { user },
    } = await this.supabase.auth.getUser();
    if (!user) {
      throw new Error('User not authenticated');
    }

    const updateData = {
      ...data,
      updated_at: new Date().toISOString(),
    };

    const { data: report, error } = await this.supabase
      .from('custom_reports')
      .update(updateData)
      .eq('id', reportId)
      .select()
      .single();

    if (error) {
      throw new Error(`Failed to update report: ${error.message}`);
    }

    // Track usage
    await this.trackUsage(reportId, user.id, 'edit');

    return report;
  }

  async deleteReport(reportId: string): Promise<void> {
    const {
      data: { user },
    } = await this.supabase.auth.getUser();
    if (!user) {
      throw new Error('User not authenticated');
    }

    const { error } = await this.supabase
      .from('custom_reports')
      .delete()
      .eq('id', reportId)
      .eq('user_id', user.id);

    if (error) {
      throw new Error(`Failed to delete report: ${error.message}`);
    }
  }

  async getReport(reportId: string): Promise<CustomReport> {
    const {
      data: { user },
    } = await this.supabase.auth.getUser();
    if (!user) {
      throw new Error('User not authenticated');
    }

    const { data: report, error } = await this.supabase
      .from('custom_reports')
      .select(
        `
        *,
        report_collaborators!inner(permission_level)
      `,
      )
      .eq('id', reportId)
      .or(
        `user_id.eq.${user.id},is_public.eq.true,report_collaborators.user_id.eq.${user.id}`,
      )
      .single();

    if (error) {
      throw new Error(`Failed to fetch report: ${error.message}`);
    }

    // Track usage
    await this.trackUsage(reportId, user.id, 'view');

    return report;
  }

  async getReports(
    page = 1,
    perPage = 10,
    filters?: any,
  ): Promise<ReportListResponse> {
    const {
      data: { user },
    } = await this.supabase.auth.getUser();
    if (!user) {
      throw new Error('User not authenticated');
    }

    const offset = (page - 1) * perPage;

    let query = this.supabase
      .from('custom_reports')
      .select('*', { count: 'exact' })
      .or(`user_id.eq.${user.id},is_public.eq.true`)
      .order('updated_at', { ascending: false })
      .range(offset, offset + perPage - 1);

    // Apply filters
    if (filters?.visualization_type) {
      query = query.eq('visualization_type', filters.visualization_type);
    }
    if (filters?.is_template !== undefined) {
      query = query.eq('is_template', filters.is_template);
    }
    if (filters?.search) {
      query = query.or(
        `report_name.ilike.%${filters.search}%,report_description.ilike.%${filters.search}%`,
      );
    }

    const { data: reports, error, count } = await query;

    if (error) {
      throw new Error(`Failed to fetch reports: ${error.message}`);
    }

    return {
      reports: reports || [],
      total_count: count || 0,
      page,
      per_page: perPage,
      has_more: (count || 0) > offset + perPage,
    };
  }

  async cloneReport(reportId: string): Promise<CustomReport> {
    const {
      data: { user },
    } = await this.supabase.auth.getUser();
    if (!user) {
      throw new Error('User not authenticated');
    }

    const { data: profile } = await this.supabase
      .from('user_profiles')
      .select('clinic_id')
      .eq('user_id', user.id)
      .single();

    if (!profile) {
      throw new Error('User profile not found');
    }

    // Get original report
    const { data: originalReport, error: fetchError } = await this.supabase
      .from('custom_reports')
      .select('*')
      .eq('id', reportId)
      .single();

    if (fetchError) {
      throw new Error(`Failed to fetch original report: ${fetchError.message}`);
    }

    // Create clone
    const cloneData = {
      report_name: `${originalReport.report_name} (Copy)`,
      report_description: originalReport.report_description,
      report_config: originalReport.report_config,
      data_sources: originalReport.data_sources,
      visualization_type: originalReport.visualization_type,
      filters: originalReport.filters,
      layout_config: originalReport.layout_config,
      is_template: false,
      is_public: false,
      user_id: user.id,
      clinic_id: profile.clinic_id,
      generation_count: 0,
    };

    const { data: clone, error } = await this.supabase
      .from('custom_reports')
      .insert([cloneData])
      .select()
      .single();

    if (error) {
      throw new Error(`Failed to clone report: ${error.message}`);
    }

    // Track usage
    await this.trackUsage(reportId, user.id, 'clone');

    return clone;
  }

  // Report Templates Management
  async getTemplates(): Promise<TemplateListResponse> {
    const { data: templates, error } = await this.supabase
      .from('report_templates')
      .select('*')
      .eq('is_active', true)
      .order('is_featured', { ascending: false })
      .order('usage_count', { ascending: false });

    if (error) {
      throw new Error(`Failed to fetch templates: ${error.message}`);
    }

    const categories = [...new Set(templates?.map((t) => t.category) || [])];
    const featured = templates?.filter((t) => t.is_featured) || [];

    return {
      templates: templates || [],
      categories,
      featured,
      total_count: templates?.length || 0,
    };
  }

  async createTemplate(
    reportId: string,
    templateData: any,
  ): Promise<ReportTemplate> {
    const {
      data: { user },
    } = await this.supabase.auth.getUser();
    if (!user) {
      throw new Error('User not authenticated');
    }

    const { data: profile } = await this.supabase
      .from('user_profiles')
      .select('clinic_id')
      .eq('user_id', user.id)
      .single();

    if (!profile) {
      throw new Error('User profile not found');
    }

    // Get report config
    const { data: report } = await this.supabase
      .from('custom_reports')
      .select('report_config, report_name, report_description')
      .eq('id', reportId)
      .eq('user_id', user.id)
      .single();

    if (!report) {
      throw new Error('Report not found or unauthorized');
    }

    const template = {
      template_name: templateData.template_name || report.report_name,
      template_description:
        templateData.template_description || report.report_description,
      category: templateData.category || 'custom',
      config_json: report.report_config,
      preview_image: templateData.preview_image,
      usage_count: 0,
      rating: 0.0,
      is_featured: false,
      is_active: true,
      tags: templateData.tags || [],
      created_by: user.id,
      clinic_id: profile.clinic_id,
    };

    const { data: newTemplate, error } = await this.supabase
      .from('report_templates')
      .insert([template])
      .select()
      .single();

    if (error) {
      throw new Error(`Failed to create template: ${error.message}`);
    }

    return newTemplate;
  }

  // Report Generation and Export
  async generateReport(request: GenerateReportRequest): Promise<any> {
    const {
      data: { user },
    } = await this.supabase.auth.getUser();
    if (!user) {
      throw new Error('User not authenticated');
    }

    // Get report configuration
    const { data: report } = await this.supabase
      .from('custom_reports')
      .select('*')
      .eq('id', request.report_id)
      .single();

    if (!report) {
      throw new Error('Report not found');
    }

    // Update generation count
    await this.supabase
      .from('custom_reports')
      .update({
        generation_count: report.generation_count + 1,
        last_generated: new Date().toISOString(),
      })
      .eq('id', request.report_id);

    // Track usage
    await this.trackUsage(request.report_id, user.id, 'generate');

    // Here you would implement the actual report generation logic
    // This would involve:
    // 1. Fetching data from configured data sources
    // 2. Applying filters and transformations
    // 3. Generating visualizations
    // 4. Formatting according to the requested format

    return {
      report_id: request.report_id,
      format: request.format || 'pdf',
      generated_at: new Date().toISOString(),
      download_url: `/api/reports/download/${request.report_id}`,
      expires_at: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(), // 24 hours
    };
  }

  // Data Source Management
  async getDataSources(): Promise<DataSourceConnector[]> {
    const {
      data: { user },
    } = await this.supabase.auth.getUser();
    if (!user) {
      throw new Error('User not authenticated');
    }

    const { data: profile } = await this.supabase
      .from('user_profiles')
      .select('clinic_id')
      .eq('user_id', user.id)
      .single();

    if (!profile) {
      throw new Error('User profile not found');
    }

    const { data: connectors, error } = await this.supabase
      .from('data_source_connectors')
      .select('*')
      .eq('clinic_id', profile.clinic_id)
      .eq('is_active', true)
      .order('connector_name');

    if (error) {
      throw new Error(`Failed to fetch data sources: ${error.message}`);
    }

    return connectors || [];
  }

  async testDataSource(
    connectorId: string,
  ): Promise<{ success: boolean; message: string }> {
    const {
      data: { user },
    } = await this.supabase.auth.getUser();
    if (!user) {
      throw new Error('User not authenticated');
    }

    const { data: connector } = await this.supabase
      .from('data_source_connectors')
      .select('*')
      .eq('id', connectorId)
      .single();

    if (!connector) {
      throw new Error('Data source not found');
    }

    // Here you would implement actual testing logic based on connector type
    const testResult = {
      success: true,
      message: 'Connection successful',
    };

    // Update test status
    await this.supabase
      .from('data_source_connectors')
      .update({
        last_tested: new Date().toISOString(),
        test_status: testResult.success ? 'success' : 'failed',
      })
      .eq('id', connectorId);

    return testResult;
  }

  // Report Collaboration
  async addCollaborator(
    reportId: string,
    userId: string,
    permissionLevel: string,
  ): Promise<ReportCollaborator> {
    const {
      data: { user },
    } = await this.supabase.auth.getUser();
    if (!user) {
      throw new Error('User not authenticated');
    }

    const collaborator = {
      report_id: reportId,
      user_id: userId,
      permission_level: permissionLevel,
      invited_by: user.id,
      invited_at: new Date().toISOString(),
    };

    const { data: newCollaborator, error } = await this.supabase
      .from('report_collaborators')
      .insert([collaborator])
      .select()
      .single();

    if (error) {
      throw new Error(`Failed to add collaborator: ${error.message}`);
    }

    return newCollaborator;
  }

  async removeCollaborator(reportId: string, userId: string): Promise<void> {
    const {
      data: { user },
    } = await this.supabase.auth.getUser();
    if (!user) {
      throw new Error('User not authenticated');
    }

    const { error } = await this.supabase
      .from('report_collaborators')
      .delete()
      .eq('report_id', reportId)
      .eq('user_id', userId);

    if (error) {
      throw new Error(`Failed to remove collaborator: ${error.message}`);
    }
  }

  async getCollaborators(reportId: string): Promise<ReportCollaborator[]> {
    const { data: collaborators, error } = await this.supabase
      .from('report_collaborators')
      .select(
        `
        *,
        user_profiles!inner(
          user_id,
          full_name,
          email
        )
      `,
      )
      .eq('report_id', reportId);

    if (error) {
      throw new Error(`Failed to fetch collaborators: ${error.message}`);
    }

    return collaborators || [];
  }

  // Report Comments
  async addComment(
    reportId: string,
    commentText: string,
    parentCommentId?: string,
  ): Promise<ReportComment> {
    const {
      data: { user },
    } = await this.supabase.auth.getUser();
    if (!user) {
      throw new Error('User not authenticated');
    }

    const comment = {
      report_id: reportId,
      user_id: user.id,
      comment_text: commentText,
      parent_comment_id: parentCommentId,
      is_resolved: false,
    };

    const { data: newComment, error } = await this.supabase
      .from('report_comments')
      .insert([comment])
      .select()
      .single();

    if (error) {
      throw new Error(`Failed to add comment: ${error.message}`);
    }

    return newComment;
  }

  async getComments(reportId: string): Promise<ReportComment[]> {
    const { data: comments, error } = await this.supabase
      .from('report_comments')
      .select(
        `
        *,
        user_profiles!inner(
          user_id,
          full_name
        )
      `,
      )
      .eq('report_id', reportId)
      .order('created_at', { ascending: true });

    if (error) {
      throw new Error(`Failed to fetch comments: ${error.message}`);
    }

    return comments || [];
  }

  async resolveComment(commentId: string): Promise<void> {
    const {
      data: { user },
    } = await this.supabase.auth.getUser();
    if (!user) {
      throw new Error('User not authenticated');
    }

    const { error } = await this.supabase
      .from('report_comments')
      .update({ is_resolved: true })
      .eq('id', commentId);

    if (error) {
      throw new Error(`Failed to resolve comment: ${error.message}`);
    }
  }

  // Report Scheduling
  async createSchedule(scheduleData: any): Promise<ReportSchedule> {
    const {
      data: { user },
    } = await this.supabase.auth.getUser();
    if (!user) {
      throw new Error('User not authenticated');
    }

    const schedule = {
      ...scheduleData,
      created_by: user.id,
      run_count: 0,
      failure_count: 0,
      next_run: this.calculateNextRun(scheduleData.schedule_config),
    };

    const { data: newSchedule, error } = await this.supabase
      .from('report_schedules')
      .insert([schedule])
      .select()
      .single();

    if (error) {
      throw new Error(`Failed to create schedule: ${error.message}`);
    }

    return newSchedule;
  }

  async getSchedules(reportId: string): Promise<ReportSchedule[]> {
    const { data: schedules, error } = await this.supabase
      .from('report_schedules')
      .select('*')
      .eq('report_id', reportId)
      .order('created_at', { ascending: false });

    if (error) {
      throw new Error(`Failed to fetch schedules: ${error.message}`);
    }

    return schedules || [];
  }

  // Analytics and Usage Tracking
  async trackUsage(
    reportId: string,
    userId: string,
    actionType: string,
    duration = 0,
  ): Promise<void> {
    try {
      // Check if there's an existing record for today
      const today = new Date().toISOString().split('T')[0];
      const { data: existing } = await this.supabase
        .from('report_usage_analytics')
        .select('*')
        .eq('report_id', reportId)
        .eq('user_id', userId)
        .eq('action_type', actionType)
        .gte('created_at', `${today}T00:00:00.000Z`)
        .lt('created_at', `${today}T23:59:59.999Z`)
        .single();

      if (existing) {
        // Update existing record
        await this.supabase
          .from('report_usage_analytics')
          .update({
            access_count: existing.access_count + 1,
            last_accessed: new Date().toISOString(),
            usage_duration: existing.usage_duration + duration,
          })
          .eq('id', existing.id);
      } else {
        // Create new record
        await this.supabase.from('report_usage_analytics').insert([
          {
            report_id: reportId,
            user_id: userId,
            action_type: actionType,
            access_count: 1,
            usage_duration: duration,
            session_data: {},
          },
        ]);
      }
    } catch (_error) {}
  }

  async getReportAnalytics(reportId: string): Promise<ReportAnalyticsResponse> {
    const { data: usageStats, error: usageError } = await this.supabase
      .from('report_usage_analytics')
      .select('*')
      .eq('report_id', reportId)
      .order('created_at', { ascending: false })
      .limit(100);

    if (usageError) {
      throw new Error(`Failed to fetch usage analytics: ${usageError.message}`);
    }

    // Calculate performance metrics
    const totalViews =
      usageStats?.reduce((sum, stat) => sum + stat.access_count, 0) || 0;
    const uniqueUsers = new Set(usageStats?.map((stat) => stat.user_id) || [])
      .size;
    const avgDuration = usageStats?.length
      ? usageStats.reduce((sum, stat) => sum + stat.usage_duration, 0) /;
        usageStats.length
      : 0;

    return {
      usage_stats: usageStats || [],
      performance_metrics: {
        average_generation_time: 0, // Would be calculated from actual generation times
        cache_hit_rate: 0.85, // Would be calculated from cache statistics
        error_rate: 0.02, // Would be calculated from error logs
        data_freshness: 0.95, // Would be calculated from data source freshness
      },
      user_engagement: {
        total_views: totalViews,
        unique_users: uniqueUsers,
        average_session_duration: avgDuration,
        bounce_rate: 0.15, // Would be calculated from session data
      },
    };
  }

  // Utility Methods
  private calculateNextRun(scheduleConfig: any): string {
    const now = new Date();
    const nextRun = new Date(now);

    switch (scheduleConfig.frequency) {
      case 'daily':
        nextRun.setDate(nextRun.getDate() + 1);
        break;
      case 'weekly':
        nextRun.setDate(nextRun.getDate() + 7);
        break;
      case 'monthly':
        nextRun.setMonth(nextRun.getMonth() + 1);
        break;
      case 'yearly':
        nextRun.setFullYear(nextRun.getFullYear() + 1);
        break;
      default:
        // Custom frequency would require more complex logic
        nextRun.setDate(nextRun.getDate() + 1);
    }

    // Set the time
    const [hours, minutes] = scheduleConfig.time.split(':');
    nextRun.setHours(
      Number.parseInt(hours, 10),
      Number.parseInt(minutes, 10),
      0,
      0,
    );

    return nextRun.toISOString();
  }

  async searchReports(query: string, filters?: any): Promise<CustomReport[]> {
    const {
      data: { user },
    } = await this.supabase.auth.getUser();
    if (!user) {
      throw new Error('User not authenticated');
    }

    let dbQuery = this.supabase
      .from('custom_reports')
      .select('*')
      .or(`user_id.eq.${user.id},is_public.eq.true`)
      .or(`report_name.ilike.%${query}%,report_description.ilike.%${query}%`)
      .order('updated_at', { ascending: false })
      .limit(20);

    if (filters?.visualization_type) {
      dbQuery = dbQuery.eq('visualization_type', filters.visualization_type);
    }

    const { data: reports, error } = await dbQuery;

    if (error) {
      throw new Error(`Failed to search reports: ${error.message}`);
    }

    return reports || [];
  }

  async getRecentReports(limit = 5): Promise<CustomReport[]> {
    const {
      data: { user },
    } = await this.supabase.auth.getUser();
    if (!user) {
      throw new Error('User not authenticated');
    }

    const { data: reports, error } = await this.supabase
      .from('custom_reports')
      .select('*')
      .or(`user_id.eq.${user.id},is_public.eq.true`)
      .order('updated_at', { ascending: false })
      .limit(limit);

    if (error) {
      throw new Error(`Failed to fetch recent reports: ${error.message}`);
    }

    return reports || [];
  }

  async getFavoriteReports(): Promise<CustomReport[]> {
    const {
      data: { user },
    } = await this.supabase.auth.getUser();
    if (!user) {
      throw new Error('User not authenticated');
    }

    // This would require a user_favorites table to track favorite reports
    // For now, return most accessed reports by the user
    const { data: analytics } = await this.supabase
      .from('report_usage_analytics')
      .select('report_id, access_count')
      .eq('user_id', user.id)
      .order('access_count', { ascending: false })
      .limit(10);

    if (!analytics?.length) {
      return [];
    }

    const reportIds = analytics.map((a) => a.report_id);

    const { data: reports, error } = await this.supabase
      .from('custom_reports')
      .select('*')
      .in('id', reportIds)
      .or(`user_id.eq.${user.id},is_public.eq.true`);

    if (error) {
      throw new Error(`Failed to fetch favorite reports: ${error.message}`);
    }

    return reports || [];
  }
}
