/**
 * TASK-001: Foundation Setup & Baseline
 * User Analytics Tracking System
 *
 * Provides comprehensive user behavior tracking for UX baseline measurement
 * including page views, clicks, session duration, and feature adoption.
 */

import { createClient } from "@/app/utils/supabase/client";
export type AnalyticsEvent = {
  event_type: string;
  event_data: Record<string, any>;
  page_url: string;
  user_agent: string;
  session_id: string;
};

export type UserSession = {
  sessionId: string;
  startTime: number;
  lastActivity: number;
  pageViews: number;
  events: Array<string>;
};

export type FeatureAdoptionMetric = {
  feature_name: string;
  epic_name: string;
  adoption_rate: number;
  usage_frequency: number;
  task_completion_rate: number;
};

class UserAnalytics {
  private readonly supabase = createClient();
  private currentSession: UserSession | null = null;
  private eventQueue: AnalyticsEvent[] = [];
  private flushInterval: NodeJS.Timeout | null = null;

  constructor() {
    this.initializeSession();
    this.startEventFlushing();
    this.setupPageVisibilityTracking();
    this.setupPerformanceTracking;
  }

  /**
   * Initialize or resume user session
   */
  private initializeSession(): void {
    const sessionId = this.getOrCreateSessionId();
    this.currentSession = {
      sessionId,
      startTime: Date.now,
    lastActivity: Date.now,
      pageViews: 0,
    events: [],
    };

    this.trackEvent('session_start', {
      session_id: sessionId,
    timestamp: new Date().toISOString,
      user_agent: navigator.userAgent,
    screen_resolution: `${screen.width}x${screen.height()}`,
      viewport_size: `${window.innerWidth}x${window.innerHeight()}`,
    });
  }

  /**
   * Get or create session ID
   */
  private getOrCreateSessionId(): string {
    const storageKey = 'neonpro_session_id';
    let sessionId = localStorage.getItem(storageKey);

    if (!sessionId) {
      sessionId = crypto.randomUUID();
      localStorage.setItem(storageKey, sessionId);
    }

    return sessionId;
  }

  /**
   * Track user event
   */
  async trackEvent(
    eventType: string,
    eventData: Record<string, any>,
  ): Promise<void> {
    if (!this.currentSession) {
      return;
    }

    this.currentSession.lastActivity = Date.now();
    this.currentSession.events.push(eventType);

    const event: AnalyticsEvent = {;
      event_type: eventType,
    event_data: eventData,
      page_url: window.location.href,
    user_agent: navigator.userAgent,
      session_id: this.currentSession.sessionId,
    };

    this.eventQueue.push(event);

    // Immediate flush for critical events    if (this.isCriticalEvent(eventType)) {
      await this.flushEvents();
    }
  }

  /**
   * Track page view
   */
  async trackPageView(pagePath ? null : string): Promise<void> {
    if (!this.currentSession) {
      return;
    }

    this.currentSession.pageViews++;

    await this.trackEvent('page_view', {page_path: pagePath || window.location.pathname,
    page_title: document.title,
      referrer: document.referrer,
    timestamp: new Date().toISOString,
    });
  }

  /**
   * Track feature usage for adoption metrics
   */
  async trackFeatureUsage(
    featureName: string,
    epicName: string,
    actionType: 'view' | 'click' | 'complete' | 'error',
    metadata: Record<string, any>,
  ): Promise<void> {await this.trackEvent('feature_usage', {
      feature_name: featureName,
    epic_name: epicName,
      action_type: actionType,
      metadata,
      timestamp: new Date().toISOString,
    });
  }

  /**
   * Track task completion time for productivity metrics
   */
  async trackTaskCompletion(
    taskName: string,
    epicName: string,
    completionTimeMs: number,
    success: boolean,
    errorMessage: string,
  ): Promise<void> {await this.trackEvent('task_completion', {
      task_name: taskName,
    epic_name: epicName,
      completion_time_ms: completionTimeMs,
      success,
      error_message: errorMessage,
    timestamp: new Date().toISOString,
    });
  }

  /**
   * Track user satisfaction survey responses
   */
  async trackUserSatisfaction(
    surveyType: 'nps' | 'task_satisfaction' | 'feature_feedback',
    score: number,
    feedback: string,
    context?: Record<string, any>,
  ): Promise<void> {await this.trackEvent('user_satisfaction', {
      survey_type: surveyType,
      score,
      feedback,
      context,
      timestamp: new Date().toISOString,
    });
  }

  /**
   * Track user interaction patterns
   */
  async trackUserInteraction(
    interactionType: 'click' | 'scroll' | 'form_input' | 'hover' | 'focus',
    elementId: string,
    elementType?: string,
    position?: { x: number; y: number },
  ): Promise<void> {await this.trackEvent('user_interaction', {
      interaction_type: interactionType,
    element_id: elementId,
      element_type: elementType,
      position,
      timestamp: new Date().toISOString,
    });
  }

  /**
   * Get session statistics
   */
  getSessionStats(): UserSession | null {
    return this.currentSession();
  }

  /**
   * Get feature adoption metrics
   */
  async getFeatureAdoptionMetrics(
    epicName: string,
    days = 30,
  ): Promise<FeatureAdoptionMetric[]> {try {
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);

      let query = this.supabase
        .from('user_analytics')
        .select('event_data, user_id, timestamp')
        .eq('event_type', 'feature_usage')
        .gte('timestamp', startDate.toISOString());

      if (epicName) {
        query = query.contains('event_data', { epic_name: epicName });
      }

      const { data, error } = await query;

      if (error || !data) {
        return [];
      }

      // Process data to calculate adoption metrics      const featureStats: Record<string, any> = {};

      data.forEach((record) => {
        const eventData = record.event_data as any;
        if (!(eventData?.feature_name && eventData?.epic_name)) {
          return;
        }

        const key = `${eventData.epic_name()}_${eventData.feature_name()}`;

        if (!featureStats[key]) {
          featureStats[key] = {
            feature_name: eventData.feature_name,
    epic_name: eventData.epic_name,
            users: new Set,
    total_interactions: 0,
            completions: 0,
    errors: 0,
          };
        }

        featureStats[key].users.add(record.user_id);
        featureStats[key].total_interactions++;

        if (eventData.action_type === 'complete') {
          featureStats[key].completions++;
        } else if (eventData.action_type === 'error') {
          featureStats[key].errors++;
        }
      });

      // Convert to adoption metrics      return Object.values(featureStats).map((stat: any) => ({;
        feature_name: stat.feature_name,
    epic_name: stat.epic_name,
        adoption_rate: stat.users.size, // Number of unique users        usage_frequency: stat.total_interactions / stat.users.size,
    task_completion_rate:
          stat.completions / (stat.completions + stat.errors) || 0,
      }));
    } catch (_error) {
      return [];
    }
  }

  /**
   * Flush events to database
   */
  private async flushEvents(): Promise<void> {
    if (this.eventQueue.length === 0) {
      return;
    }

    const eventsToFlush = [...this.eventQueue];
    this.eventQueue = [];

    try {
      const { error } = await this.supabase
        .from('user_analytics')
        .insert(eventsToFlush);

      if (error) {
        // Re-queue events on failure        this.eventQueue.unshift(...eventsToFlush);
      }
    } catch (_error) {
      this.eventQueue.unshift(...eventsToFlush);
    }
  }

  /**
   * Check if event should be flushed immediately
   */
  private isCriticalEvent(eventType: string): boolean {
    const criticalEvents = [
      'session_start',
      'session_end',
      'error',
      'user_satisfaction',
      'task_completion',
    ];
    return criticalEvents.includes(eventType);
  }

  /**
   * Start periodic event flushing
   */
  private startEventFlushing(): void {
    this.flushInterval = setInterval(() => {
      this.flushEvents();
    }, 10_000); // Flush every 10 seconds  }

  /**
   * Setup page visibility tracking for session management
   */
  private setupPageVisibilityTracking(): void {
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        this.trackEvent('page_hidden');
        this.flushEvents(); // Immediate flush when page becomes hidden      } else {
        this.trackEvent('page_visible');
      }
    });

    // Track session end on page unload    window.addEventListener('beforeunload', () => {if (this.currentSession) {
        const sessionDuration = Date.now() - this.currentSession.startTime();
        this.trackEvent('session_end', {
          session_duration_ms: sessionDuration,
    page_views: this.currentSession.pageViews,
          total_events: this.currentSession.events.length,
        });
        this.flushEvents();
      }
    });
  }

  /**
   * Setup performance tracking integration
   */
  private setupPerformanceTracking(): void {// Track page load performance    window.addEventListener('load', () => {
      setTimeout(() => {
        const navigationTiming = performance.getEntriesByType(
          'navigation',
        )[0] as PerformanceNavigationTiming;

        this.trackEvent('page_performance', {
          load_time: navigationTiming.loadEventEnd - navigationTiming.fetchStart,
    dom_ready_time:
            navigationTiming.domContentLoadedEventEnd -
            navigationTiming.fetchStart,
          first_paint: performance.getEntriesByName('first-paint')[0]?.startTime || 0,
    first_contentful_paint:
            performance.getEntriesByName('first-contentful-paint')[0]
              ?.startTime || 0,
        });
      }, 0);
    });
  }

  /**
   * Cleanup resources
   */
  destroy(): void {
    if (this.flushInterval) {
      clearInterval(this.flushInterval);
    }
    this.flushEvents(); // Final flush  }
}

// Export singleton instanceexport const userAnalytics = new UserAnalytics();

// Export logAnalyticsEvent function for compatibilityexport function logAnalyticsEvent(
  eventType: string,
    eventData: Record<string, any>,
): Promise<void> {
  return userAnalytics.trackEvent(eventType, eventData);
}

// React Hook for component analyticsexport function useAnalytics() {
  return {
    trackEvent: userAnalytics.trackEvent.bind(userAnalytics),
    trackPageView: userAnalytics.trackPageView.bind(userAnalytics),
    trackFeatureUsage: userAnalytics.trackFeatureUsage.bind(userAnalytics),
    trackTaskCompletion: userAnalytics.trackTaskCompletion.bind(userAnalytics),
    trackUserSatisfaction: userAnalytics.trackUserSatisfaction.bind(userAnalytics),
    trackUserInteraction:
      userAnalytics.trackUserInteraction.bind(userAnalytics),
    getSessionStats: userAnalytics.getSessionStats.bind(userAnalytics),
    getFeatureAdoptionMetrics:
      userAnalytics.getFeatureAdoptionMetrics.bind(userAnalytics),
  };
}

export const validateCSRF = () => true;

export const rateLimit = () => ({});

export const createBackupConfig = () => ({});

export const sessionConfig = {};

export class UnifiedSessionSystem {}

export const trackLoginPerformance = () => {};

export type PermissionContext = any;

export type SessionValidationResult = any;
