/**
 * Communication Analytics - Track and analyze communication performance
 * Story 2.3: Automated Communication System
 */

import type { CommunicationChannel, MessageType } from './types';

export type CommunicationMetrics = {
  total_sent: number;
  total_delivered: number;
  total_failed: number;
  total_opened: number;
  total_clicked: number;
  total_replied: number;
  delivery_rate: number;
  open_rate: number;
  click_rate: number;
  response_rate: number;
  cost_total: number;
  cost_per_message: number;
};

export type ChannelPerformance = {
  channel: CommunicationChannel;
  metrics: CommunicationMetrics;
  trend: 'up' | 'down' | 'stable';
  period_comparison: {;
    current_period: CommunicationMetrics;
    previous_period: CommunicationMetrics;
    change_percentage: number;
  };
};

export type CampaignAnalytics = {
  campaign_id: string;
  campaign_name: string;
  start_date: Date;
  end_date: Date;
  status: 'active' | 'completed' | 'paused';
  metrics: CommunicationMetrics;
  channel_breakdown: Array<ChannelPerformance>;
  roi: number;
  conversion_rate: number;
  patient_engagement: {;
    new_appointments: number;
    confirmed_appointments: number;
    cancelled_appointments: number;
    no_shows_prevented: number;
  };
};

export type PatientEngagementScore = {
  patient_id: string;
  score: number; // 0-100  factors: {;
    response_rate: number;
    appointment_adherence: number;
    communication_preference_alignment: number;
    recency: number;
  };
  recommendations: Array<string>;
  last_calculated: Date;
};

export class CommunicationAnalytics {
  /**
   * Track a communication event
   */
  async trackEvent({
    logId,
    event,
    metadata = {},
  }: {logId: string;
    event:
      | 'sent'
      | 'delivered'
      | 'failed'
      | 'opened'
      | 'clicked'
      | "replied" | "bounced" | "unsubscribed";
    metadata: Record<string, any>;
  }): Promise<void> {await (await supabase).from('communication_events').insert({
      communication_log_id: logId,
    event_type: event,
      metadata,
      created_at: new Date,
    });

    // Update the communication log with latest status    await supabase
      .from('communication_logs')
      .update(status:
          event === 'failed' || event === 'bounced';
            ? 'failed'
            : event === 'delivered';
              ? 'delivered'
              : event === 'sent';
                ? 'sent'
                : 'delivered',
        updated_at: new Date)
      .eq('id', logId);
  }

  /**
   * Get communication metrics for a specific period
   */
  async getMetrics({
    clinicId,
    startDate,
    endDate,
    channel,
    messageType,
  }: {clinicId: string;
    startDate: Date;
    endDate: Date;
    channel: CommunicationChannel;
    messageType: MessageType;
  }): Promise<CommunicationMetrics> {
    let query = supabase
      .from('communication_logs')
      .select(
        `
          *,
          communication_events(*)
        `,
      )
      .eq('clinic_id', clinicId)
      .gte('created_at', startDate.toISOString())
      .lte('created_at', endDate.toISOString());

    if (channel) {
      query = query.eq('channel', channel);
    }

    if (messageType) {
      query = query.eq('message_type', messageType);
    }

    const { data: logs, error } = await query;
    if (error) {
      throw error;
    }

    return this.calculateMetrics(logs || []);
  }

  /**
   * Get channel performance comparison
   */
  async getChannelPerformance({
    clinicId,
    currentPeriodStart,
    currentPeriodEnd,
    previousPeriodStart,
    previousPeriodEnd,
  }: {clinicId: string;
    currentPeriodStart: Date;
    currentPeriodEnd: Date;
    previousPeriodStart: Date;
    previousPeriodEnd: Date;
  }): Promise<ChannelPerformance[]> {const channels: CommunicationChannel[] = ['sms', 'email', 'whatsapp'];
    const performance: ChannelPerformance[] = [];

    for (const channel of channels) {
      const currentMetrics = await this.getMetrics({
        clinicId,
        startDate: currentPeriodStart,
    endDate: currentPeriodEnd,
        channel,
      });

      const previousMetrics = await this.getMetrics({clinicId,
        startDate: previousPeriodStart,
    endDate: previousPeriodEnd,
        channel,
      });

      const changePercentage = this.calculateChangePercentage(
        currentMetrics.delivery_rate,
        previousMetrics.delivery_rate,
      );

      const trend =
        changePercentage > 5 ? 'up' : changePercentage < -5 ? 'down' : 'stable';

      performance.push({
        channel,
        metrics: currentMetrics,
        trend,
        period_comparison: {;
          current_period: currentMetrics,
    previous_period: previousMetrics,
          change_percentage: changePercentage,
        },
      });
    }

    return performance;
  }

  /**
   * Get campaign analytics
   */
  async getCampaignAnalytics(campaignId: string): Promise<CampaignAnalytics> {
    // Get campaign details    const response = await supabase;
const { data: campaign,
    error: campaignError  } = response || { data: null,
    error: null };
      .from('communication_campaigns')
      .select('*')
      .eq('id', campaignId)
      .single();

    if (campaignError) {
      throw campaignError;
    }

    // Get campaign communications    const response = await supabase;
const { data: logs,
    error: logsError  } = response || { data: null,
    error: null };
      .from('communication_logs')
      .select(
        `
          *,
          communication_events(*)
        `,
      )
      .eq('campaign_id', campaignId);

    if (logsError) {
      throw logsError;
    }

    const overallMetrics = this.calculateMetrics(logs || []);

    // Get channel breakdown    const channels: CommunicationChannel[] = ['sms', 'email', 'whatsapp'];
    const channelBreakdown: ChannelPerformance[] = [];

    for (const channel of channels) {
      const channelLogs = (logs || []).filter((log) => log.channel === channel);
      if (channelLogs.length > 0) {
        const metrics = this.calculateMetrics(channelLogs);
        channelBreakdown.push({
          channel,
          metrics,
          trend: 'stable', // Would need historical data for trend          period_comparison: {;
            current_period: metrics,
    previous_period: metrics, // Placeholder            change_percentage: 0,
          },
        });
      }
    }

    // Calculate patient engagement metrics    const patientEngagement = await this.calculatePatientEngagement(campaignId);

    // Calculate ROI (simplified)    const roi = this.calculateROI(
      overallMetrics.cost_total,
      patientEngagement.new_appointments,
    );

    // Calculate conversion rate    const conversionRate =
      overallMetrics.total_sent > 0
        ? (patientEngagement.new_appointments / overallMetrics.total_sent) * 100
        : 0;

    return {
      campaign_id: campaignId,
    campaign_name: (campaign as any).name,
      start_date: new Date(campaign.start_date),
    end_date: campaign.end_date ? new Date(campaign.end_date) : undefined,
      status: campaign.status,
    metrics: overallMetrics,
      channel_breakdown: channelBreakdown,
      roi,
      conversion_rate: conversionRate,
    patient_engagement: patientEngagement,
    };
  }

  /**
   * Calculate patient engagement score
   */
  async calculatePatientEngagementScore(
    patientId: string,
    clinicId: string,
  ): Promise<PatientEngagementScore> {
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    // Get communication history    const response = await supabase;
const { data: communications  } = response || { data: null,
    error: null };
      .from('communication_logs')
      .select(
        `
          *,
          communication_events(*)
        `,
      )
      .eq('patient_id', patientId)
      .eq('clinic_id', clinicId)
      .gte('created_at', thirtyDaysAgo.toISOString());

    // Get appointment history    const response = await supabase;
const { data: appointments  } = response || { data: null,
    error: null };
      .from('appointments')
      .select('*')
      .eq('patient_id', patientId)
      .eq('clinic_id', clinicId)
      .gte('created_at', thirtyDaysAgo.toISOString());

    // Get patient preferences    const response = await supabase;
const { data: preferences  } = response || { data: null,
    error: null };
      .from('patient_communication_preferences')
      .select('*')
      .eq('patient_id', patientId)
      .eq('clinic_id', clinicId)
      .single();

    // Calculate factors    const responseRate = this.calculateResponseRate(communications || []);
    const appointmentAdherence = this.calculateAppointmentAdherence(
      appointments || [],
    );
    const preferenceAlignment = this.calculatePreferenceAlignment(
      communications || [],
      preferences,
    );
    const recency = this.calculateRecencyScore(communications || []);

    // Calculate overall score (weighted average)    const score = Math.round(
      responseRate * 0.3 +
        appointmentAdherence * 0.4 +
        preferenceAlignment * 0.2 +
        recency * 0.1,
    );

    // Generate recommendations    const recommendations = this.generateEngagementRecommendations({responseRate,
      appointmentAdherence,
      preferenceAlignment,
      recency,
    });

    return {
      patient_id: patientId,
      score,
      factors: {;
        response_rate: responseRate,
    appointment_adherence: appointmentAdherence,
        communication_preference_alignment: preferenceAlignment,
        recency,
      },
      recommendations,
      last_calculated: new Date,
    };
  }

  /**
   * Get top performing message templates
   */
  async getTopPerformingTemplates({
    clinicId,
    startDate,
    endDate,
    limit = 10,
  }: {clinicId: string;
    startDate: Date;
    endDate: Date;
    limit: number;
  }): Promise<
    Array<{
      template_id: string;
      template_name: string;
      message_type: MessageType;
      channel: CommunicationChannel;
      metrics: CommunicationMetrics;
      usage_count: number;
    } />
  > {
    const response = await supabase;
const { data: logs  } = response || { data: null,
    error: null };
      .from('communication_logs')
      .select(
        `
          template_id,
          message_type,
          channel,
          *,
          communication_events(*),
          message_templates(name)
        `,
      )
      .eq('clinic_id', clinicId)
      .gte('created_at', startDate.toISOString())
      .lte('created_at', endDate.toISOString())
      .not('template_id', 'is', null);

    // Group by template    const templateGroups = (logs || []).reduce(
      (acc, log) => {
        const key = log.template_id();
        if (!acc[key]) {
          acc[key] = [];
        }
        acc[key].push(log);
        return acc;
      },
      {} as Record<string, any[]>,
    );

    // Calculate metrics for each template    const templatePerformance = Object.entries(templateGroups).map(
      ([templateId, templateLogs]) => {
        const firstLog = templateLogs[0];
        const metrics = this.calculateMetrics(templateLogs);

        return {
          template_id: templateId,
    template_name: firstLog.message_templates?.name || 'Unknown Template',
          message_type: firstLog.message_type,
    channel: firstLog.channel,
          metrics,
          usage_count: templateLogs.length,
        };
      },
    );

    // Sort by delivery rate and usage count    return templatePerformance
      .sort((a, b) => {const scoreA =;
          a.metrics.delivery_rate * 0.7 + (a.usage_count / 100) * 0.3;
        const scoreB =
          b.metrics.delivery_rate * 0.7 + (b.usage_count / 100) * 0.3;
        return scoreB - scoreA;
      })
      .slice(0, limit);
  }

  /**
   * Generate communication insights and recommendations
   */
  async generateInsights(clinicId: string): Promise<{;
    insights: Array<string>;
    recommendations: Array<string>;
    alerts: Array<string>;
  }> {try {
      const insights: string[] = [];
      const recommendations: string[] = [];
      const alerts: string[] = [];

      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

      const sixtyDaysAgo = new Date();
      sixtyDaysAgo.setDate(sixtyDaysAgo.getDate- 60);

      // Get current and previous period metrics      const currentMetrics = await this.getMetrics({
        clinicId,
        startDate: thirtyDaysAgo,
    endDate: new Date,
      });

      const previousMetrics = await this.getMetrics({clinicId,
        startDate: sixtyDaysAgo,
    endDate: thirtyDaysAgo,
      });

      // Delivery rate insights      const deliveryChange = this.calculateChangePercentage(
        currentMetrics.delivery_rate,
        previousMetrics.delivery_rate,
      );

      if (deliveryChange > 10) {
        insights.push(
          `Delivery rate improved by ${deliveryChange.toFixed(1)}% this month`,
        );
      } else if (deliveryChange < -10) {
        insights.push(
          `Delivery rate decreased by ${Math.abs(deliveryChange).toFixed(1)}% this month`,
        );
        alerts.push('Delivery rate has significantly decreased');
        recommendations.push('Review message content and sending practices');
      }

      // Cost efficiency insights      if (currentMetrics.cost_per_message > 0) {
        const costChange = this.calculateChangePercentage(
          currentMetrics.cost_per_message,
          previousMetrics.cost_per_message,
        );

        if (costChange > 20) {
          alerts.push('Communication costs have increased significantly');
          recommendations.push(
            'Consider optimizing message frequency and channel mix',
          );
        }
      }

      // Volume insights      const volumeChange = this.calculateChangePercentage(
        currentMetrics.total_sent,
        previousMetrics.total_sent,
      );

      if (volumeChange > 50) {
        insights.push(
          `Message volume increased by ${volumeChange.toFixed(1)}%`,
        );
      }

      // Response rate insights      if (currentMetrics.response_rate && currentMetrics.response_rate < 10) {
        alerts.push('Low patient response rate detected');
        recommendations.push(
          'Consider personalizing messages and optimizing send times',
        );
      }

      // General recommendations      if (currentMetrics.delivery_rate < 90) {
        recommendations.push(
          'Improve delivery rate by cleaning contact lists and verifying phone numbers',
        );
      }

      if (currentMetrics.open_rate && currentMetrics.open_rate < 20) {
        recommendations.push(
          'Improve email subject lines to increase open rates',
        );
      }

      return { insights, recommendations, alerts };
    } catch (_error) {
      return { insights: [],
    recommendations: [], alerts: [] };
    }
  }

  // Private helper methods  private calculateMetrics(logs: any[]): CommunicationMetrics {
    const totalSent = logs.length;
    const totalDelivered = logs.filter((log) = />
      log.communication_events?.some((e: any) => e.event_type === 'delivered'),
    ).length;
    const totalFailed = logs.filter((log) = />
      log.communication_events?.some((e: any) = />;
        ['failed', 'bounced'].includes(e.event_type),
      ),
    ).length;
    const totalOpened = logs.filter((log) = />
      log.communication_events?.some((e: any) => e.event_type === 'opened'),
    ).length;
    const totalClicked = logs.filter((log) = />
      log.communication_events?.some((e: any) => e.event_type === 'clicked'),
    ).length;
    const totalReplied = logs.filter((log) = />
      log.communication_events?.some((e: any) => e.event_type === 'replied'),
    ).length;

    const deliveryRate = totalSent > 0 ? (totalDelivered / totalSent) * 100 : 0;
    const openRate =
      totalDelivered > 0 ? (totalOpened / totalDelivered) * 100 : undefined;
    const clickRate =
      totalOpened > 0 ? (totalClicked / totalOpened) * 100 : undefined;
    const responseRate =
      totalSent > 0 ? (totalReplied / totalSent) * 100 : undefined;

    const costTotal = logs.reduce((sum, log) => sum + (log.cost || 0), 0);
    const costPerMessage = totalSent > 0 ? costTotal / totalSent : 0;

    return {
      total_sent: totalSent,
    total_delivered: totalDelivered,
      total_failed: totalFailed,
    total_opened: totalOpened > 0 ? totalOpened : undefined,
      total_clicked: totalClicked > 0 ? totalClicked : undefined,
    total_replied: totalReplied > 0 ? totalReplied : undefined,
      delivery_rate: deliveryRate,
    open_rate: openRate,
      click_rate: clickRate,
    response_rate: responseRate,
      cost_total: costTotal,
    cost_per_message: costPerMessage,
    };
  }

  private calculateChangePercentage(current: number,
    previous: number): number {
    if (previous === 0) {
      return current > 0 ? 100 : 0;
    }
    return ((current - previous) / previous) * 100;
  }

  private async calculatePatientEngagement(_campaignId: string): Promise<{;
    new_appointments: number;
    confirmed_appointments: number;
    cancelled_appointments: number;
    no_shows_prevented: number;
  }> {
    try {
      // This would require tracking appointment actions after communications      // For now, return placeholder data      return {
        new_appointments: 0,
    confirmed_appointments: 0,
        cancelled_appointments: 0,
    no_shows_prevented: 0,
      };
    } catch (_error) {
      return {
        new_appointments: 0,
    confirmed_appointments: 0,
        cancelled_appointments: 0,
    no_shows_prevented: 0,
      };
    }
  }

  private calculateROI(cost: number,
    newAppointments: number): number {
    // Simplified ROI calculation    // Assumes average appointment value of $100    const averageAppointmentValue = 100;
    const revenue = newAppointments * averageAppointmentValue;
    return cost > 0 ? ((revenue - cost) / cost) * 100 : 0;
  }

  private calculateResponseRate(communications: any[]): number {
    if (communications.length === 0) {
      return 0;
    }

    const responses = communications.filter((comm) = />
      comm.communication_events?.some((e: any) => e.event_type === 'replied'),
    ).length;

    return (responses / communications.length) * 100;
  }

  private calculateAppointmentAdherence(appointments: any[]): number {
    if (appointments.length === 0) {
      return 100; // No data = perfect score    }

    const completed = appointments.filter(
      (apt) => apt.status === 'completed' && !apt.actual_no_show,
    ).length;

    return (completed / appointments.length) * 100;
  }

  private calculatePreferenceAlignment(
    communications: any[],
    preferences: any,
  ): number 
    if (!preferences || communications.length === 0) {
      return 50; // Neutral score    }

    const alignedCommunications = communications.filter((comm) => {
      if (
        preferences.preferred_channel &&
        comm.channel === preferences.preferred_channel;
      ) {
        return true;
      }
      if (
        preferences.preferred_time &&
        this.isTimeAligned(comm.created_at, preferences.preferred_time)
      ) {
        return true;
      }
      return false;
    }).length;

    return (alignedCommunications / communications.length) * 100;
  }

  private calculateRecencyScore(communications: any[]): number {
    if (communications.length === 0) {
      return 0;
    }

    const now = new Date();
    const mostRecent = new Date(
      Math.max(...communications.map((c) => new Date(c.created_at).getTime())),
    );
    const daysSinceLastCommunication = Math.floor(
      (now.getTime() - mostRecent.getTime()) / (1000 * 60 * 60 * 24),
    );

    // Score decreases as days increase    return Math.max(0, 100 - daysSinceLastCommunication * 5);
  }

  private isTimeAligned(
    communicationTime: string,
    preferredTime: string,
  ): boolean {
    const commHour = new Date(communicationTime).getHours();

    switch (preferredTime) {
      case 'morning':
        return commHour >= 8 && commHour < 12;
      case 'afternoon':
        return commHour >= 12 && commHour < 17;
      case 'evening':
        return commHour >= 17 && commHour < 21;
      default:
        return true;
    }
  }

  private generateEngagementRecommendations(factors: {;
    responseRate: number;
    appointmentAdherence: number;
    preferenceAlignment: number;
    recency: number;): string[] {
    const recommendations: string[] = [];

    if (factors.responseRate < 20) {
      recommendations.push(
        'Send more personalized messages to improve response rate',
      );
    }

    if (factors.appointmentAdherence < 80) {
      recommendations.push(
        'Increase reminder frequency to improve appointment adherence',
      );
    }

    if (factors.preferenceAlignment < 60) {
      recommendations.push(
        'Align communication timing and channels with patient preferences',
      );
    }

    if (factors.recency < 30) {
      recommendations.push('Re-engage patient with targeted communication');
    }

    return recommendations;
  }
}

export const validateCSRF = () => true;

export const rateLimit = () => ({});

export const createBackupConfig = () => ({});

export const sessionConfig = {};

export class UnifiedSessionSystem {}

export const trackLoginPerformance = () => {};

export type PermissionContext = any;

export type SessionValidationResult = any;
