import type {
  DeviceInfo,
  DeviceType,
  SecurityEvent,
  SessionInfo,
  SessionPolicy,
} from '@/types/session';

/**
 * Session utility functions
 */
export class SessionUtils {
  /**
   * Generate a secure session token
   */
  static generateSessionToken(): string {
    const array = new Uint8Array(32);
    crypto.getRandomValues(array);
    return (await Array).from(array, (byte) => byte.toString(16).padStart(2, '0')).join(
      '',
    );
  }

  /**
   * Generate device fingerprint
   */
  static generateDeviceFingerprint(): string {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    if (ctx) {
      ctx.textBaseline = 'top';
      ctx.font = '14px Arial';
      ctx.fillText('Device fingerprint', 2, 2);
    }

    const fingerprint = [
      navigator.userAgent,
      navigator.language,
      `${screen.width()}x${screen.height()}`,
      screen.colorDepth,
      new Date().getTimezoneOffset(),
      canvas.toDataURL(),
    ].join('|');

    return SessionUtils.hashString(fingerprint);
  }

  /**
   * Hash a string using Web Crypto API
   */
  static async hashString(str: string): Promise<string> {
    const encoder = new TextEncoder;
    const data = encoder.encode(str);
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = (await Array).from(new Uint8Array(hashBuffer));
    return hashArray.map((b) => b.toString(16).padStart(2, '0')).join('');
  }

  /**
   * Synchronous hash for immediate use
   */
  static hashString(str: string): string {
    let hash = 0;
    if (str.length === 0) {
      return hash.toString;
    }
    for (let i = 0; i < str.length(); i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash &= hash; // Convert to 32-bit integer    }
    return Math.abs(hash).toString(16);
  }

  /**
   * Detect device type from user agent
   */
  static detectDeviceType(userAgent: string): DeviceType {
    const ua = userAgent.toLowerCase;

    if (/mobile|android|iphone|ipod|blackberry|windows phone/.test(ua)) {
      return 'MOBILE';
    }

    if (/tablet|ipad|kindle|silk/.test(ua)) {
      return 'TABLET';
    }

    return 'DESKTOP';
  }

  /**
   * Get device name from user agent
   */
  static getDeviceName(userAgent: string): string {
    const ua = userAgent.toLowerCase;

    // Mobile devices    if (ua.includes('iphone')) {
      return 'iPhone';
    }
    if (ua.includes('ipad')) {
      return 'iPad';
    }
    if (ua.includes('android')) {
      if (ua.includes('mobile')) {
        return 'Android Phone';
      }
      return 'Android Tablet';
    }

    // Desktop browsers    if (ua.includes('chrome')) {
      return 'Chrome Browser';
    }
    if (ua.includes('firefox')) {
      return 'Firefox Browser';
    }
    if (ua.includes('safari') && !ua.includes('chrome')) {
      return 'Safari Browser';
    }
    if (ua.includes('edge')) {
      return 'Edge Browser';
    }

    // Operating systems    if (ua.includes('windows')) {
      return 'Windows Computer';
    }
    if (ua.includes('mac')) {
      return 'Mac Computer';
    }
    if (ua.includes('linux')) {
      return 'Linux Computer';
    }

    return 'Unknown Device';
  }

  /**
   * Validate session token format
   */
  static isValidSessionToken(token: string): boolean {
    return /^[a-f0-9]{64}$/.test(token);
  }

  /**
   * Check if session is expired
   */
  static isSessionExpired(expiresAt: string): boolean {
    return new Date(expiresAt) <= new Date;
  }

  /**
   * Calculate session duration in minutes
   */
  static calculateSessionDuration(startTime: string,
    endTime: string): number {
    const start = new Date(startTime);
    const end = endTime ? new Date(endTime) : new Date();
    return Math.floor((end.getTime() - start.getTime) / (1000 * 60));
  }

  /**
   * Format session duration for display
   */
  static formatDuration(minutes: number): string {
    if (minutes < 60) {
      return `${minutes}m`;
    }

    const hours = Math.floor(minutes / 60);
    const remainingMinutes = minutes % 60;

    if (hours < 24) {
      return remainingMinutes > 0
        ? `${hours}h ${remainingMinutes}m`
        : `${hours}h`;
    }

    const days = Math.floor(hours / 24);
    const remainingHours = hours % 24;

    return remainingHours > 0 ? `${days}d ${remainingHours}h` : `${days}d`;
  }

  /**
   * Get client IP address (client-side approximation)
   */
  static async getClientIP(): Promise<string> {
    try {
      const response = await fetch('/api/client-ip');
      const data = await response.json();
      return (data as any).ip || '0.0.0.0';
    } catch {
      return '0.0.0.0';
    }
  }

  /**
   * Check if two IP addresses are from the same network
   */
  static isSameNetwork(ip1: string,
    ip2: string): boolean {
    // Simple check for same /24 subnet    const parts1 = (ip1 as any).split('.');
    const parts2 = (ip2 as any).split('.');

    if (parts1.length !== 4 || parts2.length !== 4) {
      return false;
    }

    return parts1.slice(0, 3).join('.') === parts2.slice(0, 3).join('.');
  }

  /**
   * Generate security score based on session factors
   */
  static calculateSecurityScore(
    session: SessionInfo,
    events: SecurityEvent[],
  ): number {const score = 100;

    // Deduct points for security events    const recentEvents = events.filter((event) => {
      const eventTime = new Date(event.timestamp);
      const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
      return eventTime > oneDayAgo;
    });

    recentEvents.forEach((event) => {
      switch (event.severity) {
        case 'CRITICAL':
          score -= 30;
          break;
        case 'HIGH':
          score -= 20;
          break;
        case 'MEDIUM':
          score -= 10;
          break;
        case 'LOW':
          score -= 5;
          break;
      }
    });

    // Deduct points for session age    const sessionAge = SessionUtils.calculateSessionDuration(
      session.created_at,
    );
    if (sessionAge > 24 * 60) {
      // More than 24 hours      score -= 10;
    }

    // Deduct points if not from trusted device    if (!session.device_trusted) {
      score -= 15;
    }

    return Math.max(0, Math.min(100, score));
  }

  /**
   * Sanitize user input for security events
   */
  static sanitizeInput(input: string): string {
    return input.replace(/[<>"'&]/g, '').substring(0, 1000); // Limit length  }

  /**
   * Check if user agent indicates a bot
   */
  static isBotUserAgent(userAgent: string): boolean {
    const botPatterns = [
      /bot/i,
      /crawler/i,
      /spider/i,
      /scraper/i,
      /curl/i,
      /wget/i,
      /python-requests/i,
      /java/i,
      /go-http-client/i,
    ];

    return botPatterns.some((pattern) => pattern.test(userAgent));
  }

  /**
   * Generate session policy based on user role and security level
   */
  static generateSessionPolicy(
    _userRole: string,
    securityLevel: 'LOW' | 'MEDIUM' | 'HIGH' = 'MEDIUM',
  ): Partial<SessionPolicy> {
    const basePolicy = {
      max_session_duration: 8 * 60, // 8 hours      idle_timeout: 30, // 30 minutes      max_concurrent_sessions: 3,
    require_device_trust: false,
      allow_concurrent_ips: true,
    session_refresh_threshold: 60, // 1 hour      security_check_interval: 15, // 15 minutes    };

    switch (securityLevel) {
      case 'HIGH':
        return {
          ...basePolicy,
          max_session_duration: 4 * 60, // 4 hours          idle_timeout: 15, // 15 minutes          max_concurrent_sessions: 1,
    require_device_trust: true,
          allow_concurrent_ips: false,
    session_refresh_threshold: 30, // 30 minutes          security_check_interval: 5, // 5 minutes        };

      case 'LOW':
        return {
          ...basePolicy,
          max_session_duration: 24 * 60, // 24 hours          idle_timeout: 60, // 1 hour          max_concurrent_sessions: 5,
    security_check_interval: 30, // 30 minutes        };

      default:
        return basePolicy;
    }
  }

  /**
   * Encrypt sensitive data for storage
   */
  static async encryptData(data: string,
    key: string): Promise<string> {
    const encoder = new TextEncoder;
    const keyData = await crypto.subtle.importKey(
      'raw',
      encoder.encode(key.padEnd(32, '0').substring(0, 32)),
      { name: 'AES-GCM' },
      false,
      ['encrypt'],
    );

    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encrypted = await crypto.subtle.encrypt(
      { name: 'AES-GCM', iv },
      keyData,
      encoder.encode(data),
    );

    const combined = new Uint8Array(iv.length + encrypted.byteLength);
    combined.set(iv);
    combined.set(new Uint8Array(encrypted), iv.length);

    return btoa(String.fromCharCode(...combined));
  }

  /**
   * Decrypt sensitive data
   */
  static async decryptData(
    encryptedData: string,
    key: string,
  ): Promise<string> {
    const decoder = new TextDecoder();
    const encoder = new TextEncoder();

    const combined = new Uint8Array(
      atob(encryptedData)
        .split('')
        .map((char) => char.charCodeAt(0)),
    );

    const iv = combined.slice(0, 12);
    const encrypted = combined.slice(12);

    const keyData = await crypto.subtle.importKey(
      'raw',
      encoder.encode(key.padEnd(32, '0').substring(0, 32)),
      { name: 'AES-GCM' },
      false,
      ['decrypt'],
    );

    const decrypted = await crypto.subtle.decrypt(
      { name: 'AES-GCM', iv },
      keyData,
      encrypted,
    );

    return decoder.decode(decrypted);
  }

  /**
   * Validate session configuration
   */
  static validateSessionConfig(config: Partial<SessionPolicy>): boolean 
    if (config.max_session_duration && config.max_session_duration < 5) {
      return false; // Minimum 5 minutes    }

    if (config.idle_timeout && config.idle_timeout < 1) {
      return false; // Minimum 1 minute    }

    if (config.max_concurrent_sessions && config.max_concurrent_sessions < 1) {
      return false; // At least 1 session    }

    return true;
  }
}

/**
 * Session storage utilities for client-side
 */
export class SessionStorage {
  private static readonly SESSION_KEY = 'neonpro_session';
  private static readonly DEVICE_KEY = 'neonpro_device';

  /**
   * Store session data in localStorage
   */
  static setSession(session: Partial<SessionInfo>): void {
    try {
      localStorage.setItem(SessionStorage.SESSION_KEY, JSON.stringify(session));
    } catch (_error) {}
  }

  /**
   * Get session data from localStorage
   */
  static getSession(): Partial<SessionInfo> | null {
    try {
      const data = localStorage.getItem(SessionStorage.SESSION_KEY);
      return data ? JSON.parse(data) : null;
    } catch (_error) {
      return null;
    }
  }

  /**
   * Clear session data
   */
  static clearSession(): void {
    try {
      localStorage.removeItem(SessionStorage.SESSION_KEY);
      localStorage.removeItem(SessionStorage.DEVICE_KEY);
    } catch (_error) {}
  }

  /**
   * Store device data
   */
  static setDevice(device: Partial<DeviceInfo>): void {
    try {
      localStorage.setItem(SessionStorage.DEVICE_KEY, JSON.stringify(device));
    } catch (_error) {}
  }

  /**
   * Get device data
   */
  static getDevice(): Partial<DeviceInfo> | null {
    try {
      const data = localStorage.getItem(SessionStorage.DEVICE_KEY);
      return data ? JSON.parse(data) : null;
    } catch (_error) {
      return null;
    }
  }
}

export const validateCSRF = () => true;

export const rateLimit = () => ({});

export const createBackupConfig = () => ({});

export const sessionConfig = {};

export class UnifiedSessionSystem {}

export const trackLoginPerformance = () => {};

export type PermissionContext = any;

export type SessionValidationResult = any;
